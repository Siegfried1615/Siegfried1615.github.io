<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【算法】ac自动机</title>
    <link href="/2021/03/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2021/03/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动2019春招研发部分编程题</title>
    <link href="/2021/03/06/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82019%E6%98%A5%E6%8B%9B%E7%A0%94%E5%8F%91%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <url>/2021/03/06/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82019%E6%98%A5%E6%8B%9B%E7%A0%94%E5%8F%91%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li><p>我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：</p><ul><li><p>三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello</p></li><li><p>两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello</p></li><li><p>上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC</p></li></ul><p>我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！</p><p>万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……</p><p>请听题：请实现大锤的自动校对程序</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔试算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>编程题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题整理</title>
    <link href="/2021/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h3><ol><li><p>首先说一下面向对象和面向过程：</p><ul><li>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li><li>面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li></ul></li><li><p>区别和联系：</p><ul><li>语言自身：C 语言是面向过程的编程，它最重要的特点是<strong>函数</strong>，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。C++ 是面向对象的编程，<strong>类</strong>是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数</li><li>，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</li><li>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li><li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 const 关键字，等等。</li><li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li></ul></li></ol><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。<strong>（是否可变）</strong></li><li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。<strong>（是否占内存）</strong></li><li>指针可以为空，但是引用必须绑定对象。<strong>（是否可为空）</strong></li><li>指针可以有多级，但是引用只能一级。<strong>（是否能为多级）</strong></li></ul><h3 id="malloc-和new，free和delete的区别"><a href="#malloc-和new，free和delete的区别" class="headerlink" title="malloc 和new，free和delete的区别"></a>malloc 和new，free和delete的区别</h3><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p><ul><li>malloc、free 是库函数，而new、delete 是关键字。<br><code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</li><li><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。</li><li>new 分配失败时，会抛出 <code>bad_alloc </code>异常，<code>malloc</code> 分配失败时返回空指针。</li><li>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 free 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。<br><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</li></ul><h3 id="extern-C的作用"><a href="#extern-C的作用" class="headerlink" title="extern C的作用"></a>extern C的作用</h3><p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p><h3 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h3><ul><li><p><code>volatile</code> 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <code>violatile</code>，告知编译器不应对这样的对象进行优化。</p></li><li><p><code>volatile</code>不具有原子性。</p></li><li><p><code>volatile</code> 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">文件：对 I/O 设备的抽象<br>虚拟内存：对程序存储器的抽象<br>进程：对一个正在运行程序的抽象<br>虚拟机：对整个操作系统的抽象<br></code></pre></div></td></tr></table></figure><p><strong>学习操作系统能够帮助我们有效的解决<font color=pink>并发</font>问题</strong></p><h1 id="操作系统入门"><a href="#操作系统入门" class="headerlink" title="操作系统入门"></a>操作系统入门</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。</p><p>然而，程序员不会直接和这些硬件打交道，而且每位程序员不可能会掌握所有计算机系统的细节，这样我们就不用再编写代码了，所以在硬件的基础之上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为<code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。</p><p><img src="https://i.loli.net/2021/03/03/YX8KCjSGx5dElbp.png" alt="image-20210303153151233"></p><p>这是一个操作系统的简化图，最下面的是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：内核态 和 用户态，软件中最基础的部分是操作系统，它运行在<code>内核态</code> 中，内核态也称为<strong>管态</strong>和<strong>核心态</strong>，它们都是操作系统的运行状态，只不过是不同的叫法而已。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 用户态 下。</p><p>用户接口程序(shell 或者 GUI) 处于用户态中，并且它们位于用户态的最低层，允许用户运行其他程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写，如果你不喜欢某个电子邮件阅读器你可以重新写一个或者换一个，但你不能自行写一个操作系统或者是中断处理程序。这个程序由硬件保护，防止外部对其进行修改。</p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源。因此，操作系统因此必须足够了解硬件的运行。</p><p><img src="https://i.loli.net/2021/03/03/1kQXwJ8Y6CxGREg.png" alt="image-20210303154039287"></p><p>从概念上来看，一台简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O 设备都和总线串联起来并通过总线与其他设备进行通信。现代操作系统有着更为复杂的结构，会设计很多条总线。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个 CPU 的执行周期是从内存中提取第一条指令、解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</p><p>每个 CPU 都有一组可以执行的特定指令集。因此，x86 的 CPU 不能执行 ARM 的程序并且 ARM 的 CPU 也不能执行 x86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。</p><p>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。其中之一就是<font color=pink>程序计数器(program counter)</font> ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。</p><p>另一个寄存器是<font color=pink>堆栈指针(stack pointer)</font>，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</p><p>还有一个寄存器是<font color=pink>PSW(Program Status Word) 程序状态字寄存器</font> ，这个寄存器是由操作系统维护的8个字节(64位) long 类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略PSW。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW在系统调用和 I / O 中起着重要作用。</p><p>操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时，操作系统会保存所有寄存器的值，以便于后续重新运行该程序。</p><p>为了提升性能， CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个 CPU 可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对 N + 1 条指令解码，还可以读取 N + 2 条指令。像这样的组织形式被称为 流水线(pipeline)，</p><p><img src="https://i.loli.net/2021/03/03/3LKHJx7bErnAaSk.png" alt="image-20210303154138916"></p><p>比流水线更先进的设计是 <code>超标量(superscalar) </code>CPU，下面是超标量 CPU 的设计</p><p><img src="https://i.loli.net/2021/03/03/jz75onD4UhXRIE1.png" alt="image-20210303154150050"></p><p>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</p><p>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下，剩下的一部分运行在用户态下。</p><p>用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 I/O 和内存保护的所有指令是禁止执行的。当然，设置 PSW 模式的二进制位为内核态也是禁止的。</p><p>为了获取操作系统的服务，用户程序必须使用 系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</p><p>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>计算机中第二个主要的组件就是内存。理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构</p><p><img src="https://i.loli.net/2021/03/03/DAe6RK9gE4cObTn.png" alt="image-20210303155818478"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>存储器的顶层是 CPU 中的<code>寄存器</code>，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行(cache lines) 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p><p>缓存在计算机很多领域都扮演了非常重要的角色，不仅仅是 RAM 缓存行。</p><div class="note note-secondary">            <p>随机存储器（RAM）： 内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 丢失。</p>          </div><p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权，缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 /home/ast/projects/minix3/src/kernel/clock.c 这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个 Web 页面(URL) 的地址转换为网络地址(IP地址)后，这个转换结果也可以缓存起来供将来使用。</p><p>在任何缓存系统中，都会有下面这几个急需解决的问题</p><ul><li>何时把新的内容放进缓存</li><li>把新的内容应该放在缓存的哪一行</li><li>在需要空闲空间时，应该把哪块内容从缓存中移除</li><li>应该把移除的内容放在某个较大存储器的何处</li></ul><p>作者：cxuan<br>链接：<a href="https://leetcode-cn.com/leetbook/read/awesome-os-guide/egqqet/">https://leetcode-cn.com/leetbook/read/awesome-os-guide/egqqet/</a><br>来源：力扣（LeetCode）</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序的内存分区模型</title>
    <link href="/2021/02/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/02/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，则在程序结束时由操作系统回收</li></ul><p><strong>内存四区的意义</strong></p><p>不同区域存放的数据，赋予不同的生命周期，给予我们更加强大的灵活的编程</p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<strong>未执行</strong>该程序前分为两个区域</p><p><strong>代码区：</strong> </p><ul><li>存放CPU执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了他的指令</li></ul><p><strong>全局区：</strong></p><ul><li>全局变量和静态变量存放于此</li><li>全局区还包含了<strong>常量区</strong>，字符串常量和其他常量也存放在此</li><li><font color= red>该区域的数据在程序结束后由操作系统释放</font></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> g_b = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// const修饰的全局变量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_b = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// const局部变量</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;g_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;g_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const全局变量c_g_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const全局变量c_g_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串常量地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;<span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const局部变量a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const局部变量b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 输出结果</span><br>全局变量g_a地址： 15188032<br>全局变量g_b地址： 15188036<br>Const全局变量c_g_a地址： 15178816<br>Const全局变量c_g_b地址： 15178820<br>静态变量s_a地址： 15188040<br>静态变量s_b地址： 15188044<br>字符串常量地址： 15179412<br><br>局部变量a地址： 4127340<br>局部变量b地址： 4127328<br>Const局部变量a地址： 4127316<br>Const局部变量b地址： 4127304<br></code></pre></div></td></tr></table></figure><p><strong>结论</strong><br><img src="https://i.loli.net/2021/02/21/p8xBk4WmhRtAv6z.png" alt="image-20210221011618438"></p><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p><strong>栈区</strong></p><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><p><em>注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</em></p><ul><li><p>为什么不能返回局部变量地址</p><p>当前函数被执行时，开辟该区域。在函数第一次运行时，编译器对变量地址进行保留，函数运行结束后，再进行新的运算时，地址将被销毁。返回的局部变量无法被二次使用。</p></li><li><p>函数的形参同样开辟在栈区，调用函数时，形参被分配内存，函数运行结束，形参地址被销毁</p></li></ul><p><strong>堆区</strong></p><p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p><p>在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 利用new关键字 可以将数据开辟到堆区</span><br>    <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 指针本质上仍是局部变量，保存在栈区，但是指针指向的内存地址是堆区区域</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>* p = func();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 输出结果</span><br>10<br><span class="hljs-comment"># 10将到程序员回收或程序结束才被释放</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>程序内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题002-两数相加</title>
    <link href="/2021/02/17/Leetcode%E5%88%B7%E9%A2%98002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/02/17/Leetcode%E5%88%B7%E9%A2%98002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">给你两个非空的链表，表示两个非负的整数。<br>它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/17/3LPpq1nEhvAoHY9.png" alt="image-20210217225656467"></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">示例 1：<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br><br>示例 2：<br>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/add-two-numbers<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></div></td></tr></table></figure><h2 id="思路-数学进位计算"><a href="#思路-数学进位计算" class="headerlink" title="思路 - 数学进位计算"></a>思路 - 数学进位计算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode *dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        ListNode *pointer = dummyHead;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(l1 || l2)&#123;<br>            <span class="hljs-keyword">int</span> v1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> v2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> sum = v1+v2+carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> current_num = sum % <span class="hljs-number">10</span>;<br>            <br>            pointer-&gt;next = <span class="hljs-keyword">new</span> ListNode(current_num);<br>            pointer = pointer-&gt;next;<br>            <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(carry) pointer-&gt;next = <span class="hljs-keyword">new</span> ListNode(carry);<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题001-两数之和</title>
    <link href="/2021/02/17/Leetcode%E5%88%B7%E9%A2%98001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/02/17/Leetcode%E5%88%B7%E9%A2%98001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">给定一个整数数组 nums 和一个整数目标值 target<br>请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>你可以按任意顺序返回答案。<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">示例 1：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br><br>示例 2：<br>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/two-sum<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></div></td></tr></table></figure><h2 id="思路1-暴力解法"><a href="#思路1-暴力解法" class="headerlink" title="思路1 - 暴力解法"></a>思路1 - 暴力解法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;<br>              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.size();j++)&#123;<br>                  <span class="hljs-keyword">if</span>(nums[i]+nums[j]==target)&#123;<br>                      ans.push_back(i);<br>                      ans.push_back(j);<br>                      <span class="hljs-keyword">return</span> ans;<br>                  &#125;<br>              &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="思路2-哈希表"><a href="#思路2-哈希表" class="headerlink" title="思路2 - 哈希表"></a>思路2 - 哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt;nums.size();i++)&#123;<br>            <span class="hljs-keyword">auto</span> iter = mp.find(target - nums[i]);<br>            <span class="hljs-keyword">if</span> (iter != mp.end())&#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            mp.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i],i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑暗之魂学习笔记【01-玩家输入模块】【02-平滑衰减】</title>
    <link href="/2021/02/15/%E9%BB%91%E6%9A%97%E4%B9%8B%E9%AD%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/02/15/%E9%BB%91%E6%9A%97%E4%B9%8B%E9%AD%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="01-玩家输入模块"><a href="#01-玩家输入模块" class="headerlink" title="01-玩家输入模块"></a>01-玩家输入模块</h1><figure class="highlight c#"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 设置变量获取key的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyUp = <span class="hljs-string">&quot;w&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyDown = <span class="hljs-string">&quot;s&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyLeft = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyRight = <span class="hljs-string">&quot;d&quot;</span>;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 初步获取的键盘输入，只有0，1，-1，三个值</span><br>        dUp = (Input.GetKey(keyUp)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyDown)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        dRight = (Input.GetKey(keyRight)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyLeft)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>); <br>        <br>        <span class="hljs-keyword">if</span> (Input.GetKey(keyUp)) &#123;<br>        print(<span class="hljs-string">&quot;key up is pressed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="02-平滑衰减"><a href="#02-平滑衰减" class="headerlink" title="02-平滑衰减"></a>02-平滑衰减</h1><figure class="highlight c#"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 通过变量，控制脚本的装载</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> inputEnabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// Variable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyUp = <span class="hljs-string">&quot;w&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyDown = <span class="hljs-string">&quot;s&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyLeft = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyRight = <span class="hljs-string">&quot;d&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> dUp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> dRight;<br>    <br>    <span class="hljs-comment">// 平滑过渡的坐标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _targetDUp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _targetDRight;<br>    <span class="hljs-comment">// 变化速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _velocityDUp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _velocityDRight;<br>    <br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 初步获取的键盘输入，只有0，1，-1，三个值</span><br>        _targetDUp = (Input.GetKey(keyUp)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyDown)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        _targetDRight = (Input.GetKey(keyRight)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyLeft)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 设置脚本的装载</span><br>        <span class="hljs-keyword">if</span> (inputEnabled == <span class="hljs-literal">false</span>) &#123;<br>            _targetDUp = <span class="hljs-number">0</span>;<br>            _targetDRight = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 平滑函数的四个参数（当前坐标，目标坐标，速度参数，坐标变化的完成时间）</span><br>        dUp = Mathf.SmoothDamp(dUp, _targetDUp, <span class="hljs-keyword">ref</span> _velocityDUp, <span class="hljs-number">0.1f</span>);<br>        dRight = Mathf.SmoothDamp(dRight, _targetDRight, <span class="hljs-keyword">ref</span> _velocityDRight, <span class="hljs-number">0.1f</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>黑暗之魂学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>arpg</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
