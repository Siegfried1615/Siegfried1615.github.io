<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>移动客户端总结</title>
    <link href="/2021/05/10/%E7%A7%BB%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/10/%E7%A7%BB%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h1><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>　　<strong>优点</strong>：分层，结构清晰，耦合性低，大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率，维护方便，降低了维护成本。<br>　　<strong>缺点</strong>：简单的小型项目，使用MVC设计反而会降低开发效率，层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>MVC 式的出现不仅实现了功能模块和显示模块的分离，同时它还提高了应用系统的可维护性、可扩展性、可移植性和组件的可复用性<br><strong>1、耦合性低</strong><br>　　视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码,[例如，改写jsp,html,css,javascirpt的代码，并不需要重启服务器]同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可【例如，换表名查询，更改一些查询的条件，或者使用动态sql还是静态的sql，只用更改model即可】。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。<br><strong>2、重用性高</strong><br>　　随着技术的不断进步，需要用越来越多的方式来访问应用程序。MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB(HTTP)浏览器或者无线浏览器(wap)，比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。【例如，模型层实现了同样的分页，不同的视图层可以用一万种不同的显示方法，例如百度搜索下面的分页和谷歌搜索下面的分页】MVC使开发和维护用户接口的技术含量降低。</p><p><strong>3、部署快</strong></p><p>　　使用MVC模式使开发时间得到相当大的缩减，它使程序员(Java开发人员)集中精力于业务逻辑，界面程序员(HTML和JSP开发人员)集中精力于表现形式上。【例如，前端后端可以分工作业，效率高，方便多开发人员间的分工】</p><p><strong>4、可维护性高</strong></p><p>　　分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。【例如：如果想改业务逻辑，只用改业务逻辑，如果想改视图，只用改视图，如果想增加功能，只需要增加即可，分层最大的好处就是容易后期维护降低维护成本，和增加新的功能，提高代码重用性，从而提高开发效率】</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p><strong>1、没有明确的定义</strong></p><p>　　完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。同时由于模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难。每个构件在使用之前都需要经过彻底的测试。</p><p><strong>2、不适合小型，中等规模的应用程序</strong></p><p>　　花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。【这个是最明显的缺点，例如我们仅仅需要到数据库查信息，如果不分层设计我们可以直接从视图型层到模型去访问，效率上会有所提高，如果以代码的复杂性为代价，多了一层，代码量大大增加，在这个时候就降低了开发效率】</p><p><strong>3、增加系统结构和实现的复杂性</strong></p><p>　　对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p><p><strong>4、视图与控制器间的过于紧密的连接</strong></p><p>　　视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。【例如，不可能总是在jsp页面中直接访问模型，一般放在逻辑控制层进行处理，servlet】</p><p><strong>5、视图对模型数据的低效率访问</strong><br>　　依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。【例如，页面的有一部分数据我并没有更新，但是提交到模型层照样会去获得返回显示 】</p><h1 id="HTTPDNS和localDNS"><a href="#HTTPDNS和localDNS" class="headerlink" title="HTTPDNS和localDNS"></a>HTTPDNS和localDNS</h1><p>HTTPDNS使用HTTP协议进行域名解析，代替现有基于UDP的DNS协议，域名解析请求直接发送到阿里云的HTTPDNS服务器，从而绕过运营商的Local DNS，能够避免Local DNS造成的域名劫持问题和调度不精准问题。</p><p>localdns发送udp请求到53端口，httpdns发送http请求到dns服务器<br>localdns存在问题，httpdns进行了规避<br>域名缓存问题，可能导致负载均衡失效<br>域名转发问题，无法获得真实客户端ip，可能导致跨运营商访问<br>出口NAT问题，无法获得真实客户端ip<br>域名更新问题，无法获取最新结果<br>解析延迟，遍历多层dns服务器，时间较长</p><h1 id="安卓系统架构"><a href="#安卓系统架构" class="headerlink" title="安卓系统架构"></a>安卓系统架构</h1><p>Android的系统体系结构分为<strong>四层</strong>，自顶向下分别是：</p><ul><li>应用程序(Applications)</li><li>应用程序框架(Application Frameworks)</li><li>系统运行库与Android运行环境(Libraris &amp; Android Runtime)</li><li>Linux内核(Linux Kernel)</li></ul><h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><h2 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h2><p>了解Activity的生命周期，需要了解：</p><ol><li>四种状态</li><li>七个重要方法</li><li>三个嵌套循环</li><li>其他</li></ol><h2 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h2><p>四种状态包括</p><ul><li>活动（Active/Running）状态</li><li>暂停(Paused)状态</li><li>停止(Stopped)状态</li><li>非活动（Dead）状态</li></ul><h3 id="1-活动（Active-Running）状态"><a href="#1-活动（Active-Running）状态" class="headerlink" title="1. 活动（Active/Running）状态"></a>1. 活动（Active/Running）状态</h3><p>当Activity运行在屏幕前台(处于当前任务活动栈的最上面),此时它获取了焦点能响应用户的操作,属于运行状态，同一个时刻只会有一个Activity 处于活动(Active)或运行(Running)状态。</p><p>此状态由onResume()进入，由onPause()退出</p><h3 id="2-暂停-Paused-状态"><a href="#2-暂停-Paused-状态" class="headerlink" title="2. 暂停(Paused)状态"></a>2. 暂停(Paused)状态</h3><p>当Activity失去焦点(如在它之上有另一个透明的Activity或返回桌面)它将处于暂停, 再进而进入其他状态。暂停的Activity仍然是存活状态(它保留着所有的状态和成员信息并保持和窗口管理器的连接),但是当系统内存极小时可以被系统杀掉。Android7.0后, 多窗口模式下失去焦点的Activity也将进入onPause，但这不意味着Activity中的活动(动画、视频)等会暂停。虽然官方文档使用的是”an activity is going into the background” 来描述，但这不意味着一个Toast或者由本Activity创建的Dialog会调用onPause。结合<a href="https://hit-alibaba.github.io/interview/Android/basic/Android-LaunchMode.html">这里</a>对Activity的栈机制不难理解，只要当前Activity仍处于栈顶，系统就默认其仍处于活跃状态。</p><p>此状态由onPause()进入，可能下一步进入onResume()或者onCreate()重新唤醒软件，或者被onStop()杀掉</p><h3 id="3-停止-Stopped-状态"><a href="#3-停止-Stopped-状态" class="headerlink" title="3. 停止(Stopped)状态"></a>3. 停止(Stopped)状态</h3><p>完全被另一个Activity遮挡时处于停止状态,它仍然保留着所有的状态和成员信息。只是对用户不可见,当其他地方需要内存时它往往被系统杀掉。</p><p>该状态由onStop()进入，如果被杀掉，可能进入onCreate()或onRestart()，如果彻底死亡，进入onDestroy()</p><h2 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h2><p>Service有两种启动方式:</p><ul><li><code>startService()</code> 启动本地服务<code>Local Service</code></li><li><code>bindService()</code> 启动远程服务<code>Remote Service</code></li></ul><p>远程服务允许暴露接口并让系统内不同程序相互注册调用。Local Service无法抵抗一些系统清理程序如MIUI自带的内存清除。</p><p>具体如何防止自己的Service被杀死可以看这个博客<a href="http://blog.csdn.net/mad1989/article/details/22492519">Android开发之如何保证Service不被杀掉（broadcast+system/app）</a>，已经做到很变态的程度了。此外今天看到<a href="http://www.zhihu.com/question/28876912#answer-12365467">如何看待 MIUI 工程师袁军对 QQ 后台机制的评论？</a>，QQ的开启一个像素在前台的做法真的是…呵呵</p><p>两种不同的启动方式决定了<code>Service</code>具有两种生命周期的可能（并非互斥的两种）。概括来说，<code>Service</code>在被创建之后都会进入回调<code>onCreate()</code>方法，随后根据启动方式分别回调<code>onStartCommand()</code>方法和<code>onBind()</code>方法。如果<code>Service</code>是经由<code>bindService()</code>启动，则需要所有client全部调用<code>unbindService()</code>才能将<code>Service</code>释放等待系统回收。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>移动客户端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络总结</title>
    <link href="/2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ARP协议的工作过程"><a href="#ARP协议的工作过程" class="headerlink" title="ARP协议的工作过程"></a>ARP协议的工作过程</h1><p>首先，每个主机会在自己的ARP缓冲区中建立一个ARP列表，用来表示IP地址和MAC地址之间的对应关系。</p><p>当源主机要发送数据的时候，首先检查ARP表中是否有对应的IP地址的目的主机MAC地址，如果有，直接发送数据，如果没有，就像本网段的所有主机发送ARP数据包（包括源主机IP、源主机MAC、目的主机IP）</p><p>当本网络所有主机收到该ARP数据包时，先检查其中的目的主机IP是否是自己的IP，如果不是，就忽略，如果是，则先取出源主机IP与MAC写入自己的ARP标红，如果已经存在就覆盖。然后将自己的MAC地址写入ARP响应包中，返回给源主机。</p><p>最后，源主机收到ARP响应包之后，将目的主机的IP和MAC地址写入ARP列表，并利用这个信息进行数据传输，如果源主机一直没有收到ARP响应包的话，就表示ARP查询失败</p><h2 id="浏览器输入一个URL（网址）后的过程涉及到哪些网络协议，请具体描述。"><a href="#浏览器输入一个URL（网址）后的过程涉及到哪些网络协议，请具体描述。" class="headerlink" title="浏览器输入一个URL（网址）后的过程涉及到哪些网络协议，请具体描述。"></a>浏览器输入一个URL（网址）后的过程涉及到哪些网络协议，请具体描述。</h2><p>浏览器输入一个URL并回车：</p><p>首先进行域名解析，<strong>浏览器</strong>搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表。若没有，则搜索<strong>操作系统</strong>的DNS缓存；若没有，则将域名发送至本地域名服务器（递归查询方式），<strong>本地域名服务器</strong>查询自己的DNS缓存，查找成功则返回结果，否则，本地的DNS服务器向<strong>根域名服务器</strong>发出查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p><p>得到IP地址以后，浏览器就要与服务器建立一个HTTP连接，因此要用到HTTP协议。HTTP生成一个GET请求报文。</p><p>接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息。</p><p>然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址。</p><p>接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层。</p><p>服务器响应请求并请求客户端要的资源，传回给客户端。</p><p>断开TCP连接，浏览器对页面进行渲染呈现给客户端。</p><h1 id="Socket步骤"><a href="#Socket步骤" class="headerlink" title="Socket步骤"></a>Socket步骤</h1><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>(1) 创建ServerSocket对象，绑定监听端口；<br> (2) 通过accept()方法监听客户端请求；<br> (3) 连接建立后，通过输入流读取客户端发送的请求信息；<br> (4) 通过输出流向客户端发送相应信息；<br> (5) 关闭响应资源。</p><h2 id="1-2-客户端"><a href="#1-2-客户端" class="headerlink" title="1.2 客户端"></a>1.2 客户端</h2><p>(1) 创建Socket对象，指明需要连接的服务器地址和端口；<br> (2) 连接建立后，通过输出流向服务器端发送请求信息；<br> (3) 通过输入流获取服务器端返回的响应信息；<br> (4) 关闭响应资源。</p><h1 id="私有（保留）地址"><a href="#私有（保留）地址" class="headerlink" title="私有（保留）地址"></a>私有（保留）地址</h1><p>A类 10.0.0.0 – 10.255.255.255 </p><p>B类 172.16.0.0 – 172.31.255.255</p><p>C类 192.168.0.0 – 192.168.255.255</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库知识点</title>
    <link href="/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>索引是帮助MySQL高效获取数据的数据结构，简单理解为：排好序的快速查找数据结构</p><h1 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h1><p>1、主键自动创建唯一索引<br>2、频繁作为查询条件的字段应当创建索引<br>3、查询中与其他表关联的字段，即外键适合创建索引<br>4、查询中排序的字段适合创建索引，因为排序字段若通过索引去访问将大大提高排序速度<br>5、查询中统计或者分组的字段适合创建索引<br>6、找基数大的字段建立索引</p><h1 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h1><p>1、频繁更新的字段，经常增删改的表，不适合创建索引<br>2、WHERE条件里用不到字段不适合创建索引<br>3、表记录太少的情况无需建立索引<br>4、如果某个数据列中包含许多重复的内容，为它建立索引就没有太大的实际效果</p><h1 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="headerlink" title="聚簇索引/非聚簇索引"></a>聚簇索引/非聚簇索引</h1><p>聚簇索引：Innodb的主键索引，非叶子节点存储的是索引指针，叶子节点存储的是既有索引也有数据<br>非聚簇索引：MyISAM中索引和数据文件分开存储，B+Tree的叶子节点存储的是数据存放的地址，而不是具体的数据<br>如果一颗大的B+树索引数据结构里，叶子节点就是数据页自己本身，那么此时我们就可以称这颗 B+树索引为聚簇索引<br>MySQL使用B+树作为索引结构</p><h1 id="索引为什么能加快查询速度"><a href="#索引为什么能加快查询速度" class="headerlink" title="索引为什么能加快查询速度"></a>索引为什么能加快查询速度</h1><p>因为数据库在执行一条语句的时候，默认的方式是根据搜索条件进行全表扫描，如果遇到匹配条件的就加入搜索结果集合，如果对某一个字段添加索引的话，查询时就会先去索引列表中一次定位到特定值的行数，减少遍历匹配的行数，达到增加查询速度的目的</p><h1 id="联合索引在什么情况下使用"><a href="#联合索引在什么情况下使用" class="headerlink" title="联合索引在什么情况下使用"></a>联合索引在什么情况下使用</h1><p>联合索引可以缩小搜索的范围，和两个单列索引不同，当同时执行两个单列索引所返回的数据量都很大时，可以考虑使用联合索引缩小搜索范围</p><h1 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h1><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>根据定义，原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。即要么转账成功，要么转账失败<br>怎么保证原子性的<br><strong>利用Innodb的undo log</strong></p><p>undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息</p><p>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据<br>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子</p><p><strong>隔离性</strong></p><p>根据定义，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰</p><p>怎么保证隔离性的：<strong>利用的是锁和MVCC机制</strong></p><p><strong>持久性</strong></p><p>根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</p><p>怎么保证持久性的</p><p>利用Innodb的redo log</p><p>当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚数据还是提交数据</p><p><strong>一致性</strong></p><p>根据定义，一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的</p><p>那什么是合法的数据状态</p><p>这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>*<em>读未提交</em><br>当隔离级别设置为Read uncommitted 时，就可能出现脏读</p><p><strong>读已提交</strong><br>Oracle和SQL Server默认隔离级别<br>当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读</p><p><strong>可重复读</strong><br>MySQL默认隔离级别<br>Repeatable read避免了不可重复读，但还有可能出现幻读</p><p><strong>可序列化</strong><br>Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读</p><h1 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h1><p>1.InnoDB支持事务，MyISAM不支持</p><p>2.InnoDB支持外键，MyISAM不支持</p><p>3.InnoDB支持行锁和表锁，MyISAM只支持表锁</p><p>4.InnoDB支持聚簇索引，数据和索引聚集在一起。MyISAM不支持聚簇索引，数据和索引是分开存储的</p><p>5.COUNT()函数</p><p>关于MyISAM有这样一个误解，就是执行COUNT()函数会非常快。这个论断需要有一个前提条件，没有任何WHERE条件的<code>COUNT(*)</code>才非常快。因为MyISAM用一个变量保存了表的行数，当没有WHERE条件时可以直接读取这个值即可。而如果存在WHERE条件时，MyISAM没有任何优势，比起InnoDB可能慢，也可能快</p><p>6.主键，因为InnoDB支持聚簇索引，必须要有主键，MyISAM可以没有主键</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主库将变更写入 <code>binlog</code> 日志，从库连接到主库之后，主库会创建一个<code>log dump</code> 线程，用于发送 <code>bin log</code> 的内容。<br>从库开启同步以后，会创建一个 IO 线程用来连接主库，请求主库中更新的 <code>bin log</code>，I/O 线程接收到主库 <code>binlog dump</code> 进程发来的更新之后，保存在本地 <code>relay</code> 日志中。<br>接着从库中有一个 SQL 线程负责读取 <code>relay log</code> 中的内容，同步到数据库存储中，也就是在自己本地进行回放，最终保证主从数据的一致性。</p><p><strong>主从复制下的延时问题</strong><br>解决这个问题的关键是要让从服务也用多线程并行复制binlog数据<br>MySQL自5.7版本后就已经支持并行复制了。可以在从服务上设置 <code>slave_parallel_workers</code>为一个大于0的数，然后把<code>slave_parallel_type</code>参数设置为<code> LOGICAL_CLOCK</code>，这就可以了</p><p><strong>为了解决主从同步延迟的问题，通常有以下几个方法</strong><br>1.敏感业务强制读主库<br>在开发中有部分业务需要写库后实时读数据，这一类操作通常可以通过强制读主库来解决<br>2.关键业务不进行读写分离<br>对一致性不敏感的业务，比如电商中的订单评论、个人信息等可以进行读写分离，对一致性要求比较高的业务，比如金融支付，不进行读写分离，避免延迟导致的问题。</p><h1 id="B-树比B树更适合数据库索引的原因"><a href="#B-树比B树更适合数据库索引的原因" class="headerlink" title="B+树比B树更适合数据库索引的原因"></a>B+树比B树更适合数据库索引的原因</h1><p>1.B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</p><p>2.由于非叶子节点不存储 data，所以一个节点可以存储更多的索引节点，每个节点能索引的范围更大更精确。也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高</p><p>3.B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询</p><p>*<em>使用B树的好处**</em><br>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><p><strong>使用B+树的好处</strong><br>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p><strong>最佳左前缀法则</strong></p><ul><li>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且 不跳过索引中的列</li><li>不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描</li><li>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</li><li>尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *</li><li>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</li><li>索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描</li><li>索引字段使用like以通配符开头（%字符串）时，会导致索引失效而转向全表扫描</li><li>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</li><li>索引字段使用 or 时，会导致索引失效而转向全表扫描</li></ul><h1 id="MVCC的含义，如何实现的。"><a href="#MVCC的含义，如何实现的。" class="headerlink" title="MVCC的含义，如何实现的。"></a>MVCC的含义，如何实现的。</h1><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC，是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。<br>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p><strong>第一范式</strong>，是指没有重复的列， 表示数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p><strong>第二范式</strong>，是指属性完全依赖主键， 要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。为了解决严重的数据冗余问题。</p><p><strong>第三范式</strong>，是要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p><h1 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h1><p>MySQL主键不是自增长，会发生页分裂<br>索引运作的一个核心基础就是要求你后一个 数据页的主键值都大于前面一个数据页的主键值，但是如果你的主键是自增的，那还可以保证这一点， 因为你新插入后一个数据页的主键值一定都大于前一个数据页的主键值。<br>但是有时候你的主键并不是自增长的，所以可能会出现你后一个数据页的主键值里，有的主键是小于前一个数据页的主键值的<br>页分裂的过程，核心目标就是保证下一个数据页里的主键值都比上一个数据页里的主键值要大</p><h1 id="Nginx-代理"><a href="#Nginx-代理" class="headerlink" title="Nginx 代理"></a>Nginx 代理</h1><p><strong>正向代理的概念：</strong></p><p>正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。这个过程当中客户端需要知道代理服务器地址，并配置连接</p><p><strong>反向代理的概念：</strong></p><p>反向代理是指 客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的</p><p>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；</p><p>而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡是指如何将网络请求派发到集群中的一个或多个节点上处理，一般来说，传统的负载均衡可以分为硬件负载均衡和软件负载均衡<br>硬件负载均衡，就是通过专门的硬件来实现负载均衡<br>软件负载均衡则是通过负载均衡软件实现，常见的就是 Nginx</p><p><strong>常见的负载均衡策略</strong></p><blockquote><p>轮询策略</p></blockquote><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> backserver &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.14</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.15</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>加权轮询</p></blockquote><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">upstream backserver &#123;<br>   <span class="hljs-built_in"> server </span>192.168.0.14 <span class="hljs-attribute">weight</span>=3;<br>   <span class="hljs-built_in"> server </span>192.168.0.15 <span class="hljs-attribute">weight</span>=7;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>随机策略</p></blockquote><p>随机策略和轮询相似，从列表中随机的取一个，最好不要应用随机策略，可能会导致请求不均匀</p><blockquote><p>最小响应时间</p></blockquote><p>这个主要是在一些对请求延时敏感的场景中，在进行路由时，会优先发送给响应时间最小的节点</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">upstream backserver &#123;<br>    server server1<span class="hljs-comment">;</span><br>    server server2<span class="hljs-comment">;</span><br>    fair<span class="hljs-comment">;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>url_hash（第三方）</strong></p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> backserver &#123;<br>    <span class="hljs-attribute">server</span> squid1:<span class="hljs-number">3128</span>;<br>    <span class="hljs-attribute">server</span> squid2:<span class="hljs-number">3128</span>;<br>    <span class="hljs-attribute">hash</span> $request_uri;<br>    <span class="hljs-attribute">hash_method</span> crc32;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>最小并发数策略</p></blockquote><p>最小并发策略会记录当前时刻每个节点正在处理的事务数，在路由时选择并发最小的节点，最小并发策略可以比较好地反应服务器运行情况，适用于对系统负载较为敏感的场景</p><blockquote><p>ip_hash</p></blockquote><p>如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器</p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>面试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis知识点总结</title>
    <link href="/2021/05/06/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/06/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p><ul><li><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>命令序列化，按顺序执行</li><li>原子性</li><li>三阶段: 开始事务 - 命令入队 - 执行事务</li><li>命令：MULTI/EXEC/DISCARD</li></ul></li><li><h3 id="发布订阅-Pub-Sub"><a href="#发布订阅-Pub-Sub" class="headerlink" title="发布订阅(Pub/Sub)"></a>发布订阅(Pub/Sub)</h3><ul><li>Pub/sub是一种消息通讯模式</li><li>Pub发送消息, Sub接受消息</li><li>Redis客户端可以订阅任意数量的频道</li><li>“fire and forgot”, 发送即遗忘</li><li>命令：Publish/Subscribe/Psubscribe/UnSub</li></ul></li></ul><p>相比于其他数据库类型，Redis具备的特点是：</p><ul><li>C/S通讯模型</li><li>单进程单线程模型</li><li>丰富的数据类型</li><li>操作具有原子性</li><li>持久化</li><li>高并发读写</li><li>支持lua脚本</li></ul><h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><p><strong>String类型：</strong><br>它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。<br>对每种数据类型，Redis都提供了丰富的操作命令，如：<br>GET/MGET<br>SET/SETEX/MSET/MSETNX<br>INCR/DECR<br>GETSET<br>DEL</p><p><strong>哈希类型：</strong><br>该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。<br>Hash的操作命令如下：<br>HGET/HMGET/HGETALL<br>HSET/HMSET/HSETNX<br>HEXISTS/HLEN<br>HKEYS/HDEL<br>HVALS<br>列表类型：<br>该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。</p><p><strong>List的操作命令如下：</strong><br>LPUSH/LPUSHX/LPOP/RPUSH/RPUSHX/RPOP/LINSERT/LSET<br>LINDEX/LRANGE<br>LLEN/LTRIM</p><p><strong>集合类型：</strong><br>Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。<br>Set类型的底层是通过哈希表实现的，其操作命令为：<br>SADD/SPOP/SMOVE/SCARD<br>SINTER/SDIFF/SDIFFSTORE/SUNION<br>Set类型主要应用于：在某些场景，如社交场景中，通过交集、并集和差集运算，通过Set类型可以非常方便地查找共同好友、共同关注和共同偏好等社交关系。</p><p><strong>顺序集合类型：</strong><br>ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。<br>ZSet命令：<br>ZADD/ZPOP/ZMOVE/ZCARD/ZCOUNT<br>ZINTER/ZDIFF/ZDIFFSTORE/ZUNION</p><h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">CONFIG SET maxmemory 4gb   // 设置缓存大小<br></code></pre></div></td></tr></table></figure><p><strong>noeviction 策略:默认</strong><br>一旦缓存被写满了，再有写请求来时，<code>Redis</code> 不再提供服务，而是直接返回错误</p><p><strong>volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu 这四种淘汰策略:·</strong></p><ul><li><p>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</p></li><li><p>volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p></li><li><p>volatile-lru 会使用 <code>LRU</code> 算法筛选设置了过期时间的键值对。</p></li><li><p>volatile-lfu 会使用<code>LFU</code> 算法选择设置了过期时间的键值对。</p></li></ul><p><strong>allkeys-lru、allkeys-random、allkeys-lfu 这三种淘汰策略:</strong></p><ul><li><p>allkeys-random 策略，从所有键值对中随机选择并删除数据；</p></li><li><p>allkeys-lru 策略，使用 <code>LRU</code> 算法在所有数据中进行筛选。</p></li><li><p>allkeys-lfu 策略，使用 <code>LFU</code> 算法在所有数据中进行筛选。</p></li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU 会把所有的数据组织成一个链表，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据<br>缺点:</p><ul><li>使用链表, 有额外空间开销</li><li>当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><p>在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p><blockquote><p>利用时间戳来优化</p></blockquote><p>Redis 提供了一个配置参数<code>maxmemory-samples</code>，这个参数就是 Redis 选出的数据个数 N。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">CONFIG <span class="hljs-keyword">SET</span> maxmemory-samples <span class="hljs-comment">100</span><br></code></pre></div></td></tr></table></figure><p>使用建议:</p><ul><li>优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。</li><li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。</li><li>如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。</li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 持久化（也称作快照持久化）是指将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是<code> .rdb</code><br>rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取 rdb 快照文件恢复数据<br>最核心的是 rdbSave 和 rdbLoad 两个函数， 前者用于生成 RDB 文件并保存到磁盘，而后者则用于将 RDB 文件中的数据重新载入到内存中</p><p><strong>BGSAVE 是触发 RDB 持久化的主流方式</strong></p><ul><li>客户端发起 BGSAVE 命令，Redis 主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回</li><li>父进程 fork 一个子进程 （fork 的过程中会造成阻塞的情况），这个过程可以使用 info stats 命令查看<code>latest_fork_usec</code>选项，查看最近一次 fork 操作消耗的时间，单位是微秒</li><li>父进程 fork 完成之后，则会返回 Background saving started 的信息提示，此时 fork 阻塞解除</li><li>fork 创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件</li><li>子进程备份完毕后向父进程发送完成信息，父进程更新统计信息</li></ul><p><strong>RDB 的优缺点</strong></p><blockquote><p>优点</p></blockquote><ul><li>RDB 是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份、灾难恢复</li><li>可以最大化 Redis 的性能，在保存 RDB 文件，服务器进程只需 fork 一个子进程来完成 RDB 文件的创建，父进程不需要做 IO 操作</li><li>与 AOF 持久化方式相比，恢复大数据集的时候会更快</li></ul><blockquote><p>缺点</p></blockquote><ul><li>RDB 的数据安全性是不如 AOF 的，保存整个数据集是个重量级的过程，根据配置可能要几分钟才进行一次持久化，如果服务器宕机，那么就可能丢失几分钟的数据</li><li>Redis 数据集较大时，fork 的子进程要完成快照会比较耗费 CPU 和时间</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><strong>AOF的执行流程</strong><br>AOF 文件的写入流程可以分为以下 3 个步骤：</p><ol><li>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 <code>aof_buf</code></li><li>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 <code>aof_buf</code> 的数据同步到硬盘</li><li>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩</li></ol><p><strong>文件写入和文件同步</strong></p><p>Redis 提供了多种 AOF 缓存区的文件同步策略，相关策略涉及到操作系统的 write() 函数和 fsync() 函数，说明如下：</p><blockquote><ol><li>write()</li></ol></blockquote><p>为了提高文件的写入效率，当用户调用 write 函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p><blockquote><ol><li>fsync()</li></ol></blockquote><p>虽然操作系统底层对 write() 函数进行了优化 ，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数 fsync() ，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。</p><p>Redis 提供了 appendfsync 配置项来控制 AOF 缓存区的文件同步策略，appendfsync 可配置以下三种策略：</p><ul><li><strong>appendfsync always</strong>：每执行一次命令保存一次</li></ul><p>命令写入 <code>aof_buf</code> 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的</p><ul><li><strong>appendfsync no</strong>：不保存</li></ul><p>命令写入 <code>aof_buf</code> 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒</p><ul><li><strong>appendfsync everysec</strong>：每秒钟保存一次</li></ul><p>命令写入 <code>aof_buf </code>缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次</p><p>everysec 是前述两种策略的折中，是性能和数据安全性的平衡，因此也是 Redis 的默认配置，也是比较推崇的配置选项</p><h2 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h2><p>随着命令不断写入 AOF，文件会越来越大，导致文件占用空间变大，数据恢复时间变长。为了解决这个问题，Redis 引入了重写机制来对 AOF 文件中的写命令进行合并，进一步压缩文件体积。</p><p>AOF 文件重写指的是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件，这个过程不对旧的 AOF 文件的进行任何读写操作。</p><p><strong>重写流程</strong></p><p>下面以手动触发 AOF 重写为例，当 bgrewriteaof 命令被执行时，AOF 文件重写的流程如下：</p><ul><li>客户端通过 bgrewriteaof 命令对 Redis 主进程发起 AOF 重写请求</li><li>当前不存在正在执行 <code>bgsave/bgrewriteaof</code> 的子进程时，Redis 主进程通过 fork 操作创建子进程，这个过程主进程是阻塞的。如果发现 bgrewriteaof 子进程直接返回；如果发现 bgsave 子进程则等 bgsave 执行完成后再执行 fork 操作</li></ul><p>主进程的 fork 操作完成后，继续处理其他命令，把新的写命令同时追加到 <code>aof_buf</code> 和 <code>aof_rewrite_buf</code> 缓冲区中</p><ul><li>在文件重写完成之前，主进程会继续把写命令追加到 <code>aof_buf</code> 缓冲区，根据 appendfsync 策略同步到旧的 AOF 文件，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性</li><li>由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 <code>aof_rewrite_buf</code> 缓冲区中，避免 AOF 重写时丢失这部分数据</li></ul><p>子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件</p><p>子进程写完新的 AOF 文件后，向主进程发信号，主进程更新统计信息，具体可以通过 info persistence 查看</p><p>主进程接受到子进程的信号以后，将 <code>aof_rewrite_buf</code> 缓冲区中的写命令追加到新的 AOF 文件</p><p>主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成</p><p><strong>AOF 的优缺点</strong></p><blockquote><p>优点</p></blockquote><ul><li>数据更完整，安全性更高，秒级数据丢失（取决于 fsync 策略，如果是 everysec，最多丢失 1 秒的数据）</li><li>AOF 文件是一个只进行追加的命令文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复</li></ul><blockquote><p>缺点</p></blockquote><ul><li>对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。不过在一般情况下， 每秒 fsync 的性能依然非常高</li></ul><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p><strong>Cache Aside Pattern</strong><br>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，然后再删除缓存。</li></ul><p><strong>先删除缓存再更新DB</strong><br>两个并发操作，一个是更新操作，另一个是查询操作，删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库，于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了</p><p><strong>先更新DB再删除缓存</strong><br>一个是查询操作，一个是更新操作的并发，首先，没有了删除<code>cache</code>数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来，而不会像上面那个，后续的查询操作一直都在取老的数据</p><p><strong>解决方案大概有以下几种：</strong><br>对删除缓存进行重试，数据的一致性要求越高，我越是重试得快<br>定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载<br>给所有的缓存一个失效期</p><h1 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>如果请求一个不存在的数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透<br>如果每次都拿一个不存在的数据去查询数据库，可能会导致你的数据库压力增大<br><strong>解决办法</strong><br>1.缓存空值<br>我们可以为这些不存在<code>key</code>在缓存中设置对应的值为<code>null</code>，后面查询这个<code>key</code>的时候就不用查询数据库了，为了健壮性，我们要对这些<code>key</code>设置过期时间，以防止真的有数据<br>2.BloomFilter（布隆过滤器）<br>我们把有数据的<code>key</code>都放到<code>BloomFilter</code>中，每次查询的时候都先<code>去BloomFilter</code>判断，如果没有就直接返回null</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs htm">布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:<br><br>1. 网页爬虫对URL的去重，避免爬取相同的URL地址<br>2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）<br>3. 缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。<br>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉<br></code></pre></div></td></tr></table></figure><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，就是说某个 <code>key</code> 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 <code>key</code> 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库<br><strong>解决办法</strong><br>1.可将该热点数据设置为永不过期<br>2.采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当某一时刻发生大规模的缓存失效的情况<br><strong>解决办法</strong><br>1.Ehcache本地缓存+<code>Hystrix</code>限流&amp;降级<br>2.设置不同的失效时间<br>3.采用缓存击穿的解决办法，加锁<br>4.永不失效，就是采用定时任务对快要失效的缓存进行更新缓存和失效时间</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>redis</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2021/04/27/%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/27/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size() - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.size() - i - <span class="hljs-number">1</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>bubbleSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size()<span class="hljs-number">-1</span>; i++) &#123;<br><span class="hljs-keyword">int</span> minIndex = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.size(); j++) &#123;<br><span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>minIndex = j;<br>&#125;<br>&#125;<br>swap(arr[i], arr[minIndex]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>selectSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.size(); i++) &#123;<br><span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j - <span class="hljs-number">1</span>]);<br>j--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>insertSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.size() / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> groupStartIndex = <span class="hljs-number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;<br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.size(); currentIndex += gap) &#123;<br><span class="hljs-keyword">int</span> curNum = arr[currentIndex];<br><span class="hljs-keyword">int</span> pIndex = currentIndex - gap;<br><span class="hljs-keyword">while</span> (pIndex &gt;= groupStartIndex &amp;&amp; curNum &lt; arr[pIndex]) &#123;<br><span class="hljs-comment">// 向后挪位置</span><br>arr[pIndex + gap] = arr[pIndex];<br>pIndex -= gap;<br>&#125;<br>arr[pIndex + gap] = curNum;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>shellSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pivot = arr[start];  <span class="hljs-comment">// 取第一个数为基数</span><br>    <span class="hljs-keyword">int</span> left = start + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 从第二个数开始分区</span><br>    <span class="hljs-keyword">int</span> right = end;        <span class="hljs-comment">// 右边界</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 找到第一个大于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;<br>        <span class="hljs-comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span><br>        <span class="hljs-keyword">if</span> (left != right) &#123;<br>            swap(arr[left], arr[right]);<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span><br>    <span class="hljs-keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;<br>    <span class="hljs-comment">// 将基数和中间数交换</span><br>    <span class="hljs-keyword">if</span> (right != start) swap(arr[start],arr[right]);<br>    <span class="hljs-comment">// 返回中间值的下标</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果区域内的数字少于 2 个，退出递归</span><br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将数组分区，并获得中间值的下标</span><br>    <span class="hljs-keyword">int</span> middle = partition(arr, start, end);<br>    quickSort(arr, start, middle - <span class="hljs-number">1</span>);<br>    quickSort(arr, middle + <span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>quickSort(arr,<span class="hljs-number">0</span>,arr.size()<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 建立父節點指標和子節點指標</span><br>    <span class="hljs-keyword">int</span> dad = start;<br>    <span class="hljs-keyword">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span><br>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span><br>            son++;<br>        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span><br>            swap(arr[dad], arr[son]);<br>            dad = son;<br>            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        max_heapify(arr, i, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(arr[<span class="hljs-number">0</span>], arr[i]);<br>        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);<br>    heap_sort(arr, len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)<br>            stk.push(root);<br>        <span class="hljs-keyword">while</span>(!stk.empty())<br>        &#123;<br>            TreeNode* cur = stk.top();<br>            stk.pop();<br>            ans.push_back(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">NULL</span>)<br>                stk.push(cur-&gt;right);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">NULL</span>)<br>                stk.push(cur-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h1 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)<br>            stk.push(root);<br>        <span class="hljs-comment">// curr存储当前退出栈的结点</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(!stk.empty())<br>        &#123;<br>            TreeNode* top = stk.top();<br>            <span class="hljs-keyword">if</span>(top-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; top-&gt;left != curr &amp;&amp; top-&gt;right != curr)<br>                stk.push(top-&gt;left);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(top-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; top-&gt;right != curr)<br>                stk.push(top-&gt;right);<br>            <span class="hljs-comment">// 当左右子树都处理过或者不存在情况下，说明此结点可以弹栈</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ans.push_back(top-&gt;val);<br>                stk.pop();<br>                curr = top;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h1 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(!stk.empty() || curr != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">// 找到节点的最左侧节点，同时记录路径入栈</span><br>            <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                stk.push(curr);<br>                curr = curr-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">// top定义是此刻的弹栈元素</span><br>            TreeNode* top = stk.top();<br>            ans.push_back(top-&gt;val);<br>            stk.pop();<br>            <span class="hljs-comment">// 处理过最左侧结点后，判断其是否存在右子树</span><br>            <span class="hljs-keyword">if</span>(top-&gt;right != <span class="hljs-literal">NULL</span>)<br>                curr = top-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h1 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h1><p>洗牌算法，顾名思义，就是只利用一次循环等概率的取到不同的元素(牌)。</p><p>如果元素存在于数组中，即可将每次 random 到的元素 与 最后一个元素进行交换，然后 count–，即可。</p><p>这相当于把这个元素删除，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt; </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> rand()%a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapTwoElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*x,<span class="hljs-keyword">int</span>*y)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> temp;<br>     temp=*x;<br>     *x=*y;<br>     *y=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<br>    <span class="hljs-keyword">int</span> count_b = count;<br>    srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123; a[i] = i; &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count_b; ++i) &#123;<br>        <span class="hljs-keyword">int</span> random = randomInt(count);<br>        <span class="hljs-built_in">cout</span>&lt;&lt;a[random]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        swapTwoElement(&amp;a[random],&amp;a[count<span class="hljs-number">-1</span>]);<br>        count--;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h1><ul><li><p>定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p></li><li><p>构造：</p><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p><ol><li>将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；</li><li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li><li>从森林中删除选取的两棵树，并将新树加入森林；</li><li>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li></ol></li></ul><h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>  <strong>B-树</strong>：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：</p><p>  一棵 m 阶的B-树：</p><ol><li><p>树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。</p></li><li><p>除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。</p></li><li><p>所有的叶子结点都在相同的深度。</p><p>B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；</p></li></ol><h1 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h1><p>  Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p>  Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p><p>  Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客输入输出练习</title>
    <link href="/2021/03/25/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/03/25/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="编程题-A-B-1"><a href="#编程题-A-B-1" class="headerlink" title="[编程题]A+B(1)"></a>[编程题]A+B(1)</h1><p>输入描述</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入包括两个正整数<span class="hljs-selector-tag">a</span>,b(<span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>),输入数据包括多组。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b)&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; a+b &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-2"><a href="#编程题-A-B-2" class="headerlink" title="[编程题]A+B(2)"></a>[编程题]A+B(2)</h1><p>输入描述</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">输入第一行包括一个数据组数t<span class="hljs-comment">(1 &lt;= t &lt;= 100)</span><br>接下来每行包括两个正整数a,b<span class="hljs-comment">(1 &lt;= a, b &lt;= 10^9)</span><br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-3"><a href="#编程题-A-B-3" class="headerlink" title="[编程题]A+B(3)"></a>[编程题]A+B(3)</h1><p>输入描述</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入包括两个正整数<span class="hljs-selector-tag">a</span>,b(<span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>),输入数据有多组, 如果输入为<span class="hljs-number">0</span> <span class="hljs-number">0</span>则结束输入<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>&amp;&amp;b==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-4"><a href="#编程题-A-B-4" class="headerlink" title="[编程题]A+B(4)"></a>[编程题]A+B(4)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>), <span class="hljs-built_in">n</span>为<span class="hljs-number">0</span>的时候结束输入。<br>接下来<span class="hljs-built_in">n</span>个正整数,即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) &amp;&amp; num != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-5"><a href="#编程题-A-B-5" class="headerlink" title="[编程题]A+B(5)"></a>[编程题]A+B(5)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入的第一行包括一个正整数<span class="hljs-built_in">t</span>(<span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">t</span> &lt;= <span class="hljs-number">100</span>), 表示数据组数。<br>接下来<span class="hljs-built_in">t</span>行, 每行一组数据。<br>每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>)。<br>接下来<span class="hljs-built_in">n</span>个正整数, 即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> groups, num, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;groups);<br>    <span class="hljs-keyword">while</span>(groups--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-6"><a href="#编程题-A-B-6" class="headerlink" title="[编程题]A+B(6)"></a>[编程题]A+B(6)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>)。<br>接下来<span class="hljs-built_in">n</span>个正整数, 即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> groups, num, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;groups);<br>    <span class="hljs-keyword">while</span>(groups--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h1><p>虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页（page），每个页都是一段连续的地址。这些页被映射到物理内存（页表），但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块（称为帧，通常页和帧大小相等），还有一些没有加载在内存中的对应在硬盘上。</p><p>虚拟内存实际比物理内存要大，当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如上图的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如上图的3，4），会产生缺页中断，从硬盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将硬盘中的页换出来。</p><h1 id="虚拟内存实现"><a href="#虚拟内存实现" class="headerlink" title="虚拟内存实现"></a>虚拟内存实现</h1><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong></p><p>虚拟内存的实现有以下三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换</li></ol><h1 id="内存管理有哪几种方式"><a href="#内存管理有哪几种方式" class="headerlink" title="内存管理有哪几种方式"></a>内存管理有哪几种方式</h1><ol><li><strong>块式管理</strong> ：将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。 段式管理通过段表对应逻辑地址和物理地址。</li><li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</li></ol><p><strong>逻辑(虚拟)地址和物理地址</strong></p><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位</p><p>每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p><p>在操作系统中能同时运行多个进程；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><ul><li><p>1.创建状态</p></li><li><p>2.就绪状态</p></li><li><p>运行状态</p></li><li><p>阻塞状态</p></li><li><p>终止状态</p></li></ul><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><ul><li>创建（NEW）状态：新建线程对象</li><li>可运行（RUNNABLE）状态：线程对象被创建之后，其他线程调用了该线程的start方法，该线程的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</li><li>运行（RUNNING）状态：可运行状态的线程获得了cpu时间片后，执行程序代码</li><li>阻塞（BLOKED）状态：进入阻塞状态的原因是线程因为某种原因放弃了cpu使用权，也就是让出了cpu时间片，暂时停止运行，只有等到线程再次进入可运行状态时，才有机会获得cpu时间片再次运行。<ul><li>阻塞状态分为三种，1.等待阻塞，即运行的线程执行wait方法，JVM就会将线程放入等待队列。2.同步阻塞，运行的线程在获取对象的同步锁时，如果这个同步锁此刻正在被别的线程占用，则JVM会将该线程放入锁池。3.其他阻塞，当运行的线程执行了sleep、join或者发出了IO请求的时候，JVM会将线程置为阻塞状态，当sleep超时，join等待线程终止或者超时、IO处理完毕时，线程可以重新转入运行态。</li></ul></li><li>死亡（DEAD）状态：现成的run、main方法执行接触，或者因异常推出run方法，则线程结束生命周期。死亡的线程不可以再次复生。</li></ul><h1 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h1><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</p><h2 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道/匿名管道"></a>管道/匿名管道</h2><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><h2 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h2><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。</p><p>为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。</p><p>值的注意的是，有名管道严格遵循先进先出，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p><p>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</p><p>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p><p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p><p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p>为了获得共享资源，进程需要执行下列操作：</p><p>1.创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br>2.等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br>3.挂出一个信号量：该操作将信号量的值加1，也称为V操作。</p><h2 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字(Socket)"></a>套接字(Socket)</h2><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p><strong>临界区</strong></p><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p><p>优点：保证在某一时刻只有一个线程能访问数据的简便办法</p><p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程</p><p><strong>互斥量</strong></p><p>为协调共同对一个共享资源的单独访问而设计的</p><p>互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限</p><p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享</p><p><strong>信号量</strong></p><p>为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了</p><p><strong>事件</strong></p><p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p><p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作</p><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p><strong>先来先服务调度算法</strong></p><p>该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p><p><strong>短作业(进程)优先调度算法</strong></p><p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p><p><strong>时间片轮转法</strong></p><p>每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间</p><p><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p><p><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>1.系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p><p>2.进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</p><p><strong>四个必要条件</strong></p><p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</p><p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)</p><p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</p><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁</p><p><strong>只要我们破坏其中一个，就可以成功避免死锁的发生</strong></p><p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥</p><ol><li>对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li>对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于循环等待这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol><h1 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h1><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换</p><p>我们可以把快表理解为一种特殊的<strong>高速缓冲存储器（Cache）</strong>，其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>O多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程<br>目前支持I/O多路复用的系统调用有 <code>select，pselect，poll，epoll</code><br>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作<br>但<code>select，pselect，poll，epoll</code>本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，通过遍历<code>fdset</code>，来找到就绪的描述符。</p><p><strong>缺点</strong><br>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由<code>FD_SETSIZE</code>设置，默认值是1024<br>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll本质上和<code>select</code>没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个<code>fd</code>对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历<br>它没有最大连接数的限制，原因是它是基于链表来存储的<br>poll还有一个特点是<strong>水平触发</strong>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次<br>epoll使用事件的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，<code>epoll_wait</code>便可以收到通知<br>epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，<code>epoll_wait</code>的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数<br><strong>优点：</strong><br>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。<br>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即<code>Epoll</code>最大的优点就在于它只管你活跃的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p>内存拷贝，利用<code>mmap()</code>文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销</p><p><strong>文件描述符的操作有两种模式：LT和ET</strong></p><p>LT模式是默认模式，LT模式与ET模式的区别如下：<br>LT模式：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用<code>epoll_wait</code>时，会再次响应应用程序并通知此事件。</p><p>ET模式：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用<code>epoll_wait</code>时，不会再次响应应用程序并通知此事件。</p><p><strong>选择</strong><br>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。<br>select低效是因为每次它都需要轮询</p><h1 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO/NIO/AIO"></a>BIO/NIO/AIO</h1><ul><li>BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个线程不做任何事情会造成不必要的线程开销，当然可以通过线程池来改善。</li><li>NIO：同步非阻塞式IO，面向缓冲区，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。是基于事件驱动思想完成的。</li><li>AIO：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。reactor模型：反应器模式（事件驱动模式）：当一个主体发生改变时，所有的属性都得到通知，类似于观察者模式。</li></ul><h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><p>Reactor模型中定义的三种角色：<br><strong>Reactor</strong>：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。<br><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。<br><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理</p><h2 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h2><p>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</p><p>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</p><p>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</p><h2 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h2><p>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发</p><p>如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件</p><p>如果不是连接请求，则由 Reactor 分发调用连接对 应的Handler 来处理</p><p>Handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 Worker 线程池的某个线程处理业务</p><p>Worker 线程池会分配独立线程完成真正的业务， 并将结果返回给 Handler</p><p>Handler 收到响应后，通过 send 将结果返回给 Client</p><h1 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h1><p>流程与Reactor模式类似，区别在于proactor在IO ready事件触发后，完成IO操作再通知应用回调（被动）</p><h1 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h1><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">semaphore mutex=<span class="hljs-number">1</span>; <span class="hljs-comment">//临界区互斥信号量</span><br>semaphore empty=n;  <span class="hljs-comment">//空闲缓冲区</span><br>semaphore full=<span class="hljs-number">0</span>;  <span class="hljs-comment">//缓冲区初始化为空</span><br>producer ()<span class="hljs-comment">//生产者进程 </span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        produce an item <span class="hljs-keyword">in</span> nextp;  <span class="hljs-comment">//生产数据</span><br>        P(empty);  <span class="hljs-comment">//获取空缓冲区单元</span><br>        P(mutex);  <span class="hljs-comment">//进入临界区.</span><br>        <span class="hljs-keyword">add</span> nextp to buffer;  <span class="hljs-comment">//将数据放入缓冲区</span><br>        V(mutex);  <span class="hljs-comment">//离开临界区,释放互斥信号量</span><br>        V(full);  <span class="hljs-comment">//满缓冲区数加1</span><br>    &#125;<br>&#125;<br><br>consumer ()<span class="hljs-comment">//消费者进程</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        P(full);  <span class="hljs-comment">//获取满缓冲区单元</span><br>        P(mutex);  <span class="hljs-comment">// 进入临界区</span><br>        <span class="hljs-keyword">remove</span> an item <span class="hljs-keyword">from</span> buffer;  <span class="hljs-comment">//从缓冲区中取出数据</span><br>        V (mutex);  <span class="hljs-comment">//离开临界区，释放互斥信号量</span><br>        V (empty) ;  <span class="hljs-comment">//空缓冲区数加1</span><br>        consume the item;  <span class="hljs-comment">//消费数据</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
