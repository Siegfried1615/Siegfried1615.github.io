<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库知识点</title>
    <link href="/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>索引是帮助MySQL高效获取数据的数据结构，简单理解为：排好序的快速查找数据结构</p><h1 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h1><p>1、主键自动创建唯一索引</p><p>2、频繁作为查询条件的字段应当创建索引</p><p>3、查询中与其他表关联的字段，即外键适合创建索引</p><p>4、查询中排序的字段适合创建索引，因为排序字段若通过索引去访问将大大提高排序速度</p><p>5、查询中统计或者分组的字段适合创建索引</p><p>6、找基数大的字段建立索引</p><h1 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h1><p>1、频繁更新的字段，经常增删改的表，不适合创建索引</p><p>2、WHERE条件里用不到字段不适合创建索引</p><p>3、表记录太少的情况无需建立索引</p><p>4、如果某个数据列中包含许多重复的内容，为它建立索引就没有太大的实际效果</p><h1 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="headerlink" title="聚簇索引/非聚簇索引"></a>聚簇索引/非聚簇索引</h1><p>聚簇索引：Innodb的主键索引，非叶子节点存储的是索引指针，叶子节点存储的是既有索引也有数据</p><p>非聚簇索引：MyISAM中索引和数据文件分开存储，B+Tree的叶子节点存储的是数据存放的地址，而不是具体的数据</p><p>如果一颗大的B+树索引数据结构里，叶子节点就是数据页自己本身，那么此时我们就可以称这颗 B+树索引为聚簇索引</p><p>MySQL使用B+树作为索引结构</p><h1 id="索引为什么能加快查询速度"><a href="#索引为什么能加快查询速度" class="headerlink" title="索引为什么能加快查询速度"></a>索引为什么能加快查询速度</h1><p>因为数据库在执行一条语句的时候，默认的方式是根据搜索条件进行全表扫描，如果遇到匹配条件的就加入搜索结果集合，如果对某一个字段添加索引的话，查询时就会先去索引列表中一次定位到特定值的行数，减少遍历匹配的行数，达到增加查询速度的目的</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主库将变更写入 <code>binlog</code> 日志，从库连接到主库之后，主库会创建一个<code>log dump</code> 线程，用于发送 <code>bin log</code> 的内容。</p><p>从库开启同步以后，会创建一个 IO 线程用来连接主库，请求主库中更新的 <code>bin log</code>，I/O 线程接收到主库 <code>binlog dump</code> 进程发来的更新之后，保存在本地 <code>relay</code> 日志中。</p><p>接着从库中有一个 SQL 线程负责读取 <code>relay log</code> 中的内容，同步到数据库存储中，也就是在自己本地进行回放，最终保证主从数据的一致性。</p><p><strong>主从复制下的延时问题</strong></p><p>解决这个问题的关键是要让从服务也用多线程并行复制binlog数据</p><p>MySQL自5.7版本后就已经支持并行复制了。可以在从服务上设置 <code>slave_parallel_workers</code>为一个大于0的数，然后把<code>slave_parallel_type</code>参数设置为<code> LOGICAL_CLOCK</code>，这就可以了</p><p><strong>为了解决主从同步延迟的问题，通常有以下几个方法</strong></p><p>1.敏感业务强制读主库</p><p>在开发中有部分业务需要写库后实时读数据，这一类操作通常可以通过强制读主库来解决</p><p>2.关键业务不进行读写分离</p><p>对一致性不敏感的业务，比如电商中的订单评论、个人信息等可以进行读写分离，对一致性要求比较高的业务，比如金融支付，不进行读写分离，避免延迟导致的问题。</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p><strong>最佳左前缀法则</strong></p><ul><li><p>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且 不跳过索引中的列</p></li><li><p>不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描</p></li><li><p>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</p></li><li><p>尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *</p></li><li><p>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</p></li><li><p>索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描</p></li><li><p>索引字段使用like以通配符开头（%字符串）时，会导致索引失效而转向全表扫描</p></li><li><p>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</p></li><li><p>索引字段使用 or 时，会导致索引失效而转向全表扫描</p></li></ul><h1 id="B-树比B树更适合数据库索引的原因"><a href="#B-树比B树更适合数据库索引的原因" class="headerlink" title="B+树比B树更适合数据库索引的原因"></a>B+树比B树更适合数据库索引的原因</h1><p>1.B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</p><p>2.由于非叶子节点不存储 data，所以一个节点可以存储更多的索引节点，每个节点能索引的范围更大更精确。也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高</p><p>3.B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询</p><h1 id="MVCC的含义，如何实现的。"><a href="#MVCC的含义，如何实现的。" class="headerlink" title="MVCC的含义，如何实现的。"></a>MVCC的含义，如何实现的。</h1><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC，是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。<br>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><h1 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h1><p>MySQL主键不是自增长，会发生页分裂<br>索引运作的一个核心基础就是要求你后一个 数据页的主键值都大于前面一个数据页的主键值，但是如果你的主键是自增的，那还可以保证这一点， 因为你新插入后一个数据页的主键值一定都大于前一个数据页的主键值。<br>但是有时候你的主键并不是自增长的，所以可能会出现你后一个数据页的主键值里，有的主键是小于前一个数据页的主键值的<br>页分裂的过程，核心目标就是保证下一个数据页里的主键值都比上一个数据页里的主键值要大</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>面试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis知识点总结</title>
    <link href="/2021/05/06/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/06/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p><ul><li><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>命令序列化，按顺序执行</li><li>原子性</li><li>三阶段: 开始事务 - 命令入队 - 执行事务</li><li>命令：MULTI/EXEC/DISCARD</li></ul></li><li><h3 id="发布订阅-Pub-Sub"><a href="#发布订阅-Pub-Sub" class="headerlink" title="发布订阅(Pub/Sub)"></a>发布订阅(Pub/Sub)</h3><ul><li>Pub/sub是一种消息通讯模式</li><li>Pub发送消息, Sub接受消息</li><li>Redis客户端可以订阅任意数量的频道</li><li>“fire and forgot”, 发送即遗忘</li><li>命令：Publish/Subscribe/Psubscribe/UnSub</li></ul></li></ul><p>相比于其他数据库类型，Redis具备的特点是：</p><ul><li>C/S通讯模型</li><li>单进程单线程模型</li><li>丰富的数据类型</li><li>操作具有原子性</li><li>持久化</li><li>高并发读写</li><li>支持lua脚本</li></ul><h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><p><strong>String类型：</strong><br>它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。<br>对每种数据类型，Redis都提供了丰富的操作命令，如：<br>GET/MGET<br>SET/SETEX/MSET/MSETNX<br>INCR/DECR<br>GETSET<br>DEL</p><p><strong>哈希类型：</strong><br>该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。<br>Hash的操作命令如下：<br>HGET/HMGET/HGETALL<br>HSET/HMSET/HSETNX<br>HEXISTS/HLEN<br>HKEYS/HDEL<br>HVALS<br>列表类型：<br>该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。</p><p><strong>List的操作命令如下：</strong><br>LPUSH/LPUSHX/LPOP/RPUSH/RPUSHX/RPOP/LINSERT/LSET<br>LINDEX/LRANGE<br>LLEN/LTRIM</p><p><strong>集合类型：</strong><br>Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。<br>Set类型的底层是通过哈希表实现的，其操作命令为：<br>SADD/SPOP/SMOVE/SCARD<br>SINTER/SDIFF/SDIFFSTORE/SUNION<br>Set类型主要应用于：在某些场景，如社交场景中，通过交集、并集和差集运算，通过Set类型可以非常方便地查找共同好友、共同关注和共同偏好等社交关系。</p><p><strong>顺序集合类型：</strong><br>ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。<br>ZSet命令：<br>ZADD/ZPOP/ZMOVE/ZCARD/ZCOUNT<br>ZINTER/ZDIFF/ZDIFFSTORE/ZUNION</p><h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">CONFIG SET maxmemory 4gb   // 设置缓存大小<br></code></pre></div></td></tr></table></figure><p><strong>noeviction 策略:默认</strong><br>一旦缓存被写满了，再有写请求来时，<code>Redis</code> 不再提供服务，而是直接返回错误</p><p><strong>volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu 这四种淘汰策略:·</strong></p><ul><li><p>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</p></li><li><p>volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p></li><li><p>volatile-lru 会使用 <code>LRU</code> 算法筛选设置了过期时间的键值对。</p></li><li><p>volatile-lfu 会使用<code>LFU</code> 算法选择设置了过期时间的键值对。</p></li></ul><p><strong>allkeys-lru、allkeys-random、allkeys-lfu 这三种淘汰策略:</strong></p><ul><li><p>allkeys-random 策略，从所有键值对中随机选择并删除数据；</p></li><li><p>allkeys-lru 策略，使用 <code>LRU</code> 算法在所有数据中进行筛选。</p></li><li><p>allkeys-lfu 策略，使用 <code>LFU</code> 算法在所有数据中进行筛选。</p></li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU 会把所有的数据组织成一个链表，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据<br>缺点:</p><ul><li>使用链表, 有额外空间开销</li><li>当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><p>在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p><blockquote><p>利用时间戳来优化</p></blockquote><p>Redis 提供了一个配置参数<code>maxmemory-samples</code>，这个参数就是 Redis 选出的数据个数 N。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">CONFIG <span class="hljs-keyword">SET</span> maxmemory-samples <span class="hljs-comment">100</span><br></code></pre></div></td></tr></table></figure><p>使用建议:</p><ul><li>优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。</li><li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。</li><li>如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。</li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 持久化（也称作快照持久化）是指将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是<code> .rdb</code><br>rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取 rdb 快照文件恢复数据<br>最核心的是 rdbSave 和 rdbLoad 两个函数， 前者用于生成 RDB 文件并保存到磁盘，而后者则用于将 RDB 文件中的数据重新载入到内存中</p><p><strong>BGSAVE 是触发 RDB 持久化的主流方式</strong></p><ul><li>客户端发起 BGSAVE 命令，Redis 主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回</li><li>父进程 fork 一个子进程 （fork 的过程中会造成阻塞的情况），这个过程可以使用 info stats 命令查看<code>latest_fork_usec</code>选项，查看最近一次 fork 操作消耗的时间，单位是微秒</li><li>父进程 fork 完成之后，则会返回 Background saving started 的信息提示，此时 fork 阻塞解除</li><li>fork 创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件</li><li>子进程备份完毕后向父进程发送完成信息，父进程更新统计信息</li></ul><p><strong>RDB 的优缺点</strong></p><blockquote><p>优点</p></blockquote><ul><li>RDB 是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份、灾难恢复</li><li>可以最大化 Redis 的性能，在保存 RDB 文件，服务器进程只需 fork 一个子进程来完成 RDB 文件的创建，父进程不需要做 IO 操作</li><li>与 AOF 持久化方式相比，恢复大数据集的时候会更快</li></ul><blockquote><p>缺点</p></blockquote><ul><li>RDB 的数据安全性是不如 AOF 的，保存整个数据集是个重量级的过程，根据配置可能要几分钟才进行一次持久化，如果服务器宕机，那么就可能丢失几分钟的数据</li><li>Redis 数据集较大时，fork 的子进程要完成快照会比较耗费 CPU 和时间</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><strong>AOF的执行流程</strong><br>AOF 文件的写入流程可以分为以下 3 个步骤：</p><ol><li>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 <code>aof_buf</code></li><li>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 <code>aof_buf</code> 的数据同步到硬盘</li><li>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩</li></ol><p><strong>文件写入和文件同步</strong></p><p>Redis 提供了多种 AOF 缓存区的文件同步策略，相关策略涉及到操作系统的 write() 函数和 fsync() 函数，说明如下：</p><blockquote><ol><li>write()</li></ol></blockquote><p>为了提高文件的写入效率，当用户调用 write 函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p><blockquote><ol><li>fsync()</li></ol></blockquote><p>虽然操作系统底层对 write() 函数进行了优化 ，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数 fsync() ，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。</p><p>Redis 提供了 appendfsync 配置项来控制 AOF 缓存区的文件同步策略，appendfsync 可配置以下三种策略：</p><ul><li><strong>appendfsync always</strong>：每执行一次命令保存一次</li></ul><p>命令写入 <code>aof_buf</code> 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的</p><ul><li><strong>appendfsync no</strong>：不保存</li></ul><p>命令写入 <code>aof_buf</code> 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒</p><ul><li><strong>appendfsync everysec</strong>：每秒钟保存一次</li></ul><p>命令写入 <code>aof_buf </code>缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次</p><p>everysec 是前述两种策略的折中，是性能和数据安全性的平衡，因此也是 Redis 的默认配置，也是比较推崇的配置选项</p><h2 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h2><p>随着命令不断写入 AOF，文件会越来越大，导致文件占用空间变大，数据恢复时间变长。为了解决这个问题，Redis 引入了重写机制来对 AOF 文件中的写命令进行合并，进一步压缩文件体积。</p><p>AOF 文件重写指的是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件，这个过程不对旧的 AOF 文件的进行任何读写操作。</p><p><strong>重写流程</strong></p><p>下面以手动触发 AOF 重写为例，当 bgrewriteaof 命令被执行时，AOF 文件重写的流程如下：</p><ul><li>客户端通过 bgrewriteaof 命令对 Redis 主进程发起 AOF 重写请求</li><li>当前不存在正在执行 <code>bgsave/bgrewriteaof</code> 的子进程时，Redis 主进程通过 fork 操作创建子进程，这个过程主进程是阻塞的。如果发现 bgrewriteaof 子进程直接返回；如果发现 bgsave 子进程则等 bgsave 执行完成后再执行 fork 操作</li></ul><p>主进程的 fork 操作完成后，继续处理其他命令，把新的写命令同时追加到 <code>aof_buf</code> 和 <code>aof_rewrite_buf</code> 缓冲区中</p><ul><li>在文件重写完成之前，主进程会继续把写命令追加到 <code>aof_buf</code> 缓冲区，根据 appendfsync 策略同步到旧的 AOF 文件，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性</li><li>由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 <code>aof_rewrite_buf</code> 缓冲区中，避免 AOF 重写时丢失这部分数据</li></ul><p>子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件</p><p>子进程写完新的 AOF 文件后，向主进程发信号，主进程更新统计信息，具体可以通过 info persistence 查看</p><p>主进程接受到子进程的信号以后，将 <code>aof_rewrite_buf</code> 缓冲区中的写命令追加到新的 AOF 文件</p><p>主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成</p><p><strong>AOF 的优缺点</strong></p><blockquote><p>优点</p></blockquote><ul><li>数据更完整，安全性更高，秒级数据丢失（取决于 fsync 策略，如果是 everysec，最多丢失 1 秒的数据）</li><li>AOF 文件是一个只进行追加的命令文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复</li></ul><blockquote><p>缺点</p></blockquote><ul><li>对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。不过在一般情况下， 每秒 fsync 的性能依然非常高</li></ul><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p><strong>Cache Aside Pattern</strong><br>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，然后再删除缓存。</li></ul><p><strong>先删除缓存再更新DB</strong><br>两个并发操作，一个是更新操作，另一个是查询操作，删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库，于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了</p><p><strong>先更新DB再删除缓存</strong><br>一个是查询操作，一个是更新操作的并发，首先，没有了删除<code>cache</code>数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来，而不会像上面那个，后续的查询操作一直都在取老的数据</p><p><strong>解决方案大概有以下几种：</strong><br>对删除缓存进行重试，数据的一致性要求越高，我越是重试得快<br>定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载<br>给所有的缓存一个失效期</p><h1 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>如果请求一个不存在的数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透<br>如果每次都拿一个不存在的数据去查询数据库，可能会导致你的数据库压力增大<br><strong>解决办法</strong><br>1.缓存空值<br>我们可以为这些不存在<code>key</code>在缓存中设置对应的值为<code>null</code>，后面查询这个<code>key</code>的时候就不用查询数据库了，为了健壮性，我们要对这些<code>key</code>设置过期时间，以防止真的有数据<br>2.BloomFilter（布隆过滤器）<br>我们把有数据的<code>key</code>都放到<code>BloomFilter</code>中，每次查询的时候都先<code>去BloomFilter</code>判断，如果没有就直接返回null</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs htm">布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:<br><br>1. 网页爬虫对URL的去重，避免爬取相同的URL地址<br>2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）<br>3. 缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。<br>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉<br></code></pre></div></td></tr></table></figure><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，就是说某个 <code>key</code> 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 <code>key</code> 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库<br><strong>解决办法</strong><br>1.可将该热点数据设置为永不过期<br>2.采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当某一时刻发生大规模的缓存失效的情况<br><strong>解决办法</strong><br>1.Ehcache本地缓存+<code>Hystrix</code>限流&amp;降级<br>2.设置不同的失效时间<br>3.采用缓存击穿的解决办法，加锁<br>4.永不失效，就是采用定时任务对快要失效的缓存进行更新缓存和失效时间</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>redis</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size() - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.size() - i - <span class="hljs-number">1</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>bubbleSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size()<span class="hljs-number">-1</span>; i++) &#123;<br><span class="hljs-keyword">int</span> minIndex = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.size(); j++) &#123;<br><span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>minIndex = j;<br>&#125;<br>&#125;<br>swap(arr[i], arr[minIndex]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>selectSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.size(); i++) &#123;<br><span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j - <span class="hljs-number">1</span>]);<br>j--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>insertSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.size() / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> groupStartIndex = <span class="hljs-number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;<br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.size(); currentIndex += gap) &#123;<br><span class="hljs-keyword">int</span> curNum = arr[currentIndex];<br><span class="hljs-keyword">int</span> pIndex = currentIndex - gap;<br><span class="hljs-keyword">while</span> (pIndex &gt;= groupStartIndex &amp;&amp; curNum &lt; arr[pIndex]) &#123;<br><span class="hljs-comment">// 向后挪位置</span><br>arr[pIndex + gap] = arr[pIndex];<br>pIndex -= gap;<br>&#125;<br>arr[pIndex + gap] = curNum;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>shellSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pivot = arr[start];  <span class="hljs-comment">// 取第一个数为基数</span><br>    <span class="hljs-keyword">int</span> left = start + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 从第二个数开始分区</span><br>    <span class="hljs-keyword">int</span> right = end;        <span class="hljs-comment">// 右边界</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 找到第一个大于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;<br>        <span class="hljs-comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span><br>        <span class="hljs-keyword">if</span> (left != right) &#123;<br>            swap(arr[left], arr[right]);<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span><br>    <span class="hljs-keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;<br>    <span class="hljs-comment">// 将基数和中间数交换</span><br>    <span class="hljs-keyword">if</span> (right != start) swap(arr[start],arr[right]);<br>    <span class="hljs-comment">// 返回中间值的下标</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果区域内的数字少于 2 个，退出递归</span><br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将数组分区，并获得中间值的下标</span><br>    <span class="hljs-keyword">int</span> middle = partition(arr, start, end);<br>    quickSort(arr, start, middle - <span class="hljs-number">1</span>);<br>    quickSort(arr, middle + <span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>quickSort(arr,<span class="hljs-number">0</span>,arr.size()<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 建立父節點指標和子節點指標</span><br>    <span class="hljs-keyword">int</span> dad = start;<br>    <span class="hljs-keyword">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span><br>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span><br>            son++;<br>        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span><br>            swap(arr[dad], arr[son]);<br>            dad = son;<br>            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        max_heapify(arr, i, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(arr[<span class="hljs-number">0</span>], arr[i]);<br>        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);<br>    heap_sort(arr, len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客输入输出练习</title>
    <link href="/2021/03/25/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/03/25/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="编程题-A-B-1"><a href="#编程题-A-B-1" class="headerlink" title="[编程题]A+B(1)"></a>[编程题]A+B(1)</h1><p>输入描述</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入包括两个正整数<span class="hljs-selector-tag">a</span>,b(<span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>),输入数据包括多组。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b)&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; a+b &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-2"><a href="#编程题-A-B-2" class="headerlink" title="[编程题]A+B(2)"></a>[编程题]A+B(2)</h1><p>输入描述</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">输入第一行包括一个数据组数t<span class="hljs-comment">(1 &lt;= t &lt;= 100)</span><br>接下来每行包括两个正整数a,b<span class="hljs-comment">(1 &lt;= a, b &lt;= 10^9)</span><br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-3"><a href="#编程题-A-B-3" class="headerlink" title="[编程题]A+B(3)"></a>[编程题]A+B(3)</h1><p>输入描述</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入包括两个正整数<span class="hljs-selector-tag">a</span>,b(<span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>),输入数据有多组, 如果输入为<span class="hljs-number">0</span> <span class="hljs-number">0</span>则结束输入<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>&amp;&amp;b==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-4"><a href="#编程题-A-B-4" class="headerlink" title="[编程题]A+B(4)"></a>[编程题]A+B(4)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>), <span class="hljs-built_in">n</span>为<span class="hljs-number">0</span>的时候结束输入。<br>接下来<span class="hljs-built_in">n</span>个正整数,即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) &amp;&amp; num != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-5"><a href="#编程题-A-B-5" class="headerlink" title="[编程题]A+B(5)"></a>[编程题]A+B(5)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入的第一行包括一个正整数<span class="hljs-built_in">t</span>(<span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">t</span> &lt;= <span class="hljs-number">100</span>), 表示数据组数。<br>接下来<span class="hljs-built_in">t</span>行, 每行一组数据。<br>每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>)。<br>接下来<span class="hljs-built_in">n</span>个正整数, 即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> groups, num, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;groups);<br>    <span class="hljs-keyword">while</span>(groups--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-6"><a href="#编程题-A-B-6" class="headerlink" title="[编程题]A+B(6)"></a>[编程题]A+B(6)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>)。<br>接下来<span class="hljs-built_in">n</span>个正整数, 即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> groups, num, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;groups);<br>    <span class="hljs-keyword">while</span>(groups--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题整理</title>
    <link href="/2021/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h3><ol><li><p>首先说一下面向对象和面向过程：</p><ul><li>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li><li>面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li></ul></li><li><p>区别和联系：</p><ul><li>语言自身：C 语言是面向过程的编程，它最重要的特点是<strong>函数</strong>，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。C++ 是面向对象的编程，<strong>类</strong>是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数</li><li>，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</li><li>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li><li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 const 关键字，等等。</li><li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li></ul></li></ol><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。<strong>（是否可变）</strong></li><li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。<strong>（是否占内存）</strong></li><li>指针可以为空，但是引用必须绑定对象。<strong>（是否可为空）</strong></li><li>指针可以有多级，但是引用只能一级。<strong>（是否能为多级）</strong></li></ul><h3 id="malloc-和new，free和delete的区别"><a href="#malloc-和new，free和delete的区别" class="headerlink" title="malloc 和new，free和delete的区别"></a>malloc 和new，free和delete的区别</h3><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p><ul><li>malloc、free 是库函数，而new、delete 是关键字。<br><code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</li><li><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。</li><li>new 分配失败时，会抛出 <code>bad_alloc </code>异常，<code>malloc</code> 分配失败时返回空指针。</li><li>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 free 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。<br><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</li></ul><h3 id="extern-C的作用"><a href="#extern-C的作用" class="headerlink" title="extern C的作用"></a>extern C的作用</h3><p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p><h3 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h3><ul><li><p><code>volatile</code> 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <code>violatile</code>，告知编译器不应对这样的对象进行优化。</p></li><li><p><code>volatile</code>不具有原子性。</p></li><li><p><code>volatile</code> 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">文件：对 I/O 设备的抽象<br>虚拟内存：对程序存储器的抽象<br>进程：对一个正在运行程序的抽象<br>虚拟机：对整个操作系统的抽象<br></code></pre></div></td></tr></table></figure><p><strong>学习操作系统能够帮助我们有效的解决<font color=pink>并发</font>问题</strong></p><h1 id="操作系统入门"><a href="#操作系统入门" class="headerlink" title="操作系统入门"></a>操作系统入门</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。</p><p>然而，程序员不会直接和这些硬件打交道，而且每位程序员不可能会掌握所有计算机系统的细节，这样我们就不用再编写代码了，所以在硬件的基础之上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为<code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。</p><p><img src="https://i.loli.net/2021/03/03/YX8KCjSGx5dElbp.png" alt="image-20210303153151233"></p><p>这是一个操作系统的简化图，最下面的是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：内核态 和 用户态，软件中最基础的部分是操作系统，它运行在<code>内核态</code> 中，内核态也称为<strong>管态</strong>和<strong>核心态</strong>，它们都是操作系统的运行状态，只不过是不同的叫法而已。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 用户态 下。</p><p>用户接口程序(shell 或者 GUI) 处于用户态中，并且它们位于用户态的最低层，允许用户运行其他程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写，如果你不喜欢某个电子邮件阅读器你可以重新写一个或者换一个，但你不能自行写一个操作系统或者是中断处理程序。这个程序由硬件保护，防止外部对其进行修改。</p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源。因此，操作系统因此必须足够了解硬件的运行。</p><p><img src="https://i.loli.net/2021/03/03/1kQXwJ8Y6CxGREg.png" alt="image-20210303154039287"></p><p>从概念上来看，一台简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O 设备都和总线串联起来并通过总线与其他设备进行通信。现代操作系统有着更为复杂的结构，会设计很多条总线。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个 CPU 的执行周期是从内存中提取第一条指令、解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</p><p>每个 CPU 都有一组可以执行的特定指令集。因此，x86 的 CPU 不能执行 ARM 的程序并且 ARM 的 CPU 也不能执行 x86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。</p><p>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。其中之一就是<font color=pink>程序计数器(program counter)</font> ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。</p><p>另一个寄存器是<font color=pink>堆栈指针(stack pointer)</font>，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</p><p>还有一个寄存器是<font color=pink>PSW(Program Status Word) 程序状态字寄存器</font> ，这个寄存器是由操作系统维护的8个字节(64位) long 类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略PSW。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW在系统调用和 I / O 中起着重要作用。</p><p>操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时，操作系统会保存所有寄存器的值，以便于后续重新运行该程序。</p><p>为了提升性能， CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个 CPU 可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对 N + 1 条指令解码，还可以读取 N + 2 条指令。像这样的组织形式被称为 流水线(pipeline)，</p><p><img src="https://i.loli.net/2021/03/03/3LKHJx7bErnAaSk.png" alt="image-20210303154138916"></p><p>比流水线更先进的设计是 <code>超标量(superscalar) </code>CPU，下面是超标量 CPU 的设计</p><p><img src="https://i.loli.net/2021/03/03/jz75onD4UhXRIE1.png" alt="image-20210303154150050"></p><p>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</p><p>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下，剩下的一部分运行在用户态下。</p><p>用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 I/O 和内存保护的所有指令是禁止执行的。当然，设置 PSW 模式的二进制位为内核态也是禁止的。</p><p>为了获取操作系统的服务，用户程序必须使用 系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</p><p>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>计算机中第二个主要的组件就是内存。理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构</p><p><img src="https://i.loli.net/2021/03/03/DAe6RK9gE4cObTn.png" alt="image-20210303155818478"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>存储器的顶层是 CPU 中的<code>寄存器</code>，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行(cache lines) 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p><p>缓存在计算机很多领域都扮演了非常重要的角色，不仅仅是 RAM 缓存行。</p><div class="note note-secondary">            <p>随机存储器（RAM）： 内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 丢失。</p>          </div><p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权，缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 /home/ast/projects/minix3/src/kernel/clock.c 这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个 Web 页面(URL) 的地址转换为网络地址(IP地址)后，这个转换结果也可以缓存起来供将来使用。</p><p>在任何缓存系统中，都会有下面这几个急需解决的问题</p><ul><li>何时把新的内容放进缓存</li><li>把新的内容应该放在缓存的哪一行</li><li>在需要空闲空间时，应该把哪块内容从缓存中移除</li><li>应该把移除的内容放在某个较大存储器的何处</li></ul><p>作者：cxuan<br>链接：<a href="https://leetcode-cn.com/leetbook/read/awesome-os-guide/egqqet/">https://leetcode-cn.com/leetbook/read/awesome-os-guide/egqqet/</a><br>来源：力扣（LeetCode）</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序的内存分区模型</title>
    <link href="/2021/02/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/02/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，则在程序结束时由操作系统回收</li></ul><p><strong>内存四区的意义</strong></p><p>不同区域存放的数据，赋予不同的生命周期，给予我们更加强大的灵活的编程</p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<strong>未执行</strong>该程序前分为两个区域</p><p><strong>代码区：</strong> </p><ul><li>存放CPU执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了他的指令</li></ul><p><strong>全局区：</strong></p><ul><li>全局变量和静态变量存放于此</li><li>全局区还包含了<strong>常量区</strong>，字符串常量和其他常量也存放在此</li><li><font color= red>该区域的数据在程序结束后由操作系统释放</font></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> g_b = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// const修饰的全局变量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_b = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// const局部变量</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;g_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;g_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const全局变量c_g_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const全局变量c_g_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串常量地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;<span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const局部变量a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const局部变量b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 输出结果</span><br>全局变量g_a地址： 15188032<br>全局变量g_b地址： 15188036<br>Const全局变量c_g_a地址： 15178816<br>Const全局变量c_g_b地址： 15178820<br>静态变量s_a地址： 15188040<br>静态变量s_b地址： 15188044<br>字符串常量地址： 15179412<br><br>局部变量a地址： 4127340<br>局部变量b地址： 4127328<br>Const局部变量a地址： 4127316<br>Const局部变量b地址： 4127304<br></code></pre></div></td></tr></table></figure><p><strong>结论</strong><br><img src="https://i.loli.net/2021/02/21/p8xBk4WmhRtAv6z.png" alt="image-20210221011618438"></p><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p><strong>栈区</strong></p><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><p><em>注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</em></p><ul><li><p>为什么不能返回局部变量地址</p><p>当前函数被执行时，开辟该区域。在函数第一次运行时，编译器对变量地址进行保留，函数运行结束后，再进行新的运算时，地址将被销毁。返回的局部变量无法被二次使用。</p></li><li><p>函数的形参同样开辟在栈区，调用函数时，形参被分配内存，函数运行结束，形参地址被销毁</p></li></ul><p><strong>堆区</strong></p><p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p><p>在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 利用new关键字 可以将数据开辟到堆区</span><br>    <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 指针本质上仍是局部变量，保存在栈区，但是指针指向的内存地址是堆区区域</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>* p = func();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 输出结果</span><br>10<br><span class="hljs-comment"># 10将到程序员回收或程序结束才被释放</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>程序内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑暗之魂学习笔记【01-玩家输入模块】【02-平滑衰减】</title>
    <link href="/2021/02/15/%E9%BB%91%E6%9A%97%E4%B9%8B%E9%AD%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/02/15/%E9%BB%91%E6%9A%97%E4%B9%8B%E9%AD%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="01-玩家输入模块"><a href="#01-玩家输入模块" class="headerlink" title="01-玩家输入模块"></a>01-玩家输入模块</h1><figure class="highlight c#"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 设置变量获取key的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyUp = <span class="hljs-string">&quot;w&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyDown = <span class="hljs-string">&quot;s&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyLeft = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyRight = <span class="hljs-string">&quot;d&quot;</span>;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 初步获取的键盘输入，只有0，1，-1，三个值</span><br>        dUp = (Input.GetKey(keyUp)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyDown)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        dRight = (Input.GetKey(keyRight)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyLeft)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>); <br>        <br>        <span class="hljs-keyword">if</span> (Input.GetKey(keyUp)) &#123;<br>        print(<span class="hljs-string">&quot;key up is pressed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="02-平滑衰减"><a href="#02-平滑衰减" class="headerlink" title="02-平滑衰减"></a>02-平滑衰减</h1><figure class="highlight c#"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 通过变量，控制脚本的装载</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> inputEnabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// Variable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyUp = <span class="hljs-string">&quot;w&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyDown = <span class="hljs-string">&quot;s&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyLeft = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyRight = <span class="hljs-string">&quot;d&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> dUp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> dRight;<br>    <br>    <span class="hljs-comment">// 平滑过渡的坐标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _targetDUp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _targetDRight;<br>    <span class="hljs-comment">// 变化速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _velocityDUp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _velocityDRight;<br>    <br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 初步获取的键盘输入，只有0，1，-1，三个值</span><br>        _targetDUp = (Input.GetKey(keyUp)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyDown)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        _targetDRight = (Input.GetKey(keyRight)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyLeft)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 设置脚本的装载</span><br>        <span class="hljs-keyword">if</span> (inputEnabled == <span class="hljs-literal">false</span>) &#123;<br>            _targetDUp = <span class="hljs-number">0</span>;<br>            _targetDRight = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 平滑函数的四个参数（当前坐标，目标坐标，速度参数，坐标变化的完成时间）</span><br>        dUp = Mathf.SmoothDamp(dUp, _targetDUp, <span class="hljs-keyword">ref</span> _velocityDUp, <span class="hljs-number">0.1f</span>);<br>        dRight = Mathf.SmoothDamp(dRight, _targetDRight, <span class="hljs-keyword">ref</span> _velocityDRight, <span class="hljs-number">0.1f</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>黑暗之魂学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
