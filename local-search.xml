<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库知识点</title>
    <link href="/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>索引是帮助MySQL高效获取数据的数据结构，简单理解为：排好序的快速查找数据结构</p><h1 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h1><p>1、主键自动创建唯一索引<br>2、频繁作为查询条件的字段应当创建索引<br>3、查询中与其他表关联的字段，即外键适合创建索引<br>4、查询中排序的字段适合创建索引，因为排序字段若通过索引去访问将大大提高排序速度<br>5、查询中统计或者分组的字段适合创建索引<br>6、找基数大的字段建立索引</p><h1 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h1><p>1、频繁更新的字段，经常增删改的表，不适合创建索引<br>2、WHERE条件里用不到字段不适合创建索引<br>3、表记录太少的情况无需建立索引<br>4、如果某个数据列中包含许多重复的内容，为它建立索引就没有太大的实际效果</p><h1 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="headerlink" title="聚簇索引/非聚簇索引"></a>聚簇索引/非聚簇索引</h1><p>聚簇索引：Innodb的主键索引，非叶子节点存储的是索引指针，叶子节点存储的是既有索引也有数据<br>非聚簇索引：MyISAM中索引和数据文件分开存储，B+Tree的叶子节点存储的是数据存放的地址，而不是具体的数据<br>如果一颗大的B+树索引数据结构里，叶子节点就是数据页自己本身，那么此时我们就可以称这颗 B+树索引为聚簇索引<br>MySQL使用B+树作为索引结构</p><h1 id="索引为什么能加快查询速度"><a href="#索引为什么能加快查询速度" class="headerlink" title="索引为什么能加快查询速度"></a>索引为什么能加快查询速度</h1><p>因为数据库在执行一条语句的时候，默认的方式是根据搜索条件进行全表扫描，如果遇到匹配条件的就加入搜索结果集合，如果对某一个字段添加索引的话，查询时就会先去索引列表中一次定位到特定值的行数，减少遍历匹配的行数，达到增加查询速度的目的</p><h1 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h1><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>根据定义，原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。即要么转账成功，要么转账失败<br>怎么保证原子性的<br><strong>利用Innodb的undo log</strong></p><p>undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息</p><p>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据<br>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子</p><p><strong>隔离性</strong></p><p>根据定义，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰</p><p>怎么保证隔离性的：<strong>利用的是锁和MVCC机制</strong></p><p><strong>持久性</strong></p><p>根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</p><p>怎么保证持久性的</p><p>利用Innodb的redo log</p><p>当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚数据还是提交数据</p><p><strong>一致性</strong></p><p>根据定义，一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的</p><p>那什么是合法的数据状态</p><p>这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>*<em>读未提交</em><br>当隔离级别设置为Read uncommitted 时，就可能出现脏读</p><p><strong>读已提交</strong><br>Oracle和SQL Server默认隔离级别<br>当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读</p><p><strong>可重复读</strong><br>MySQL默认隔离级别<br>Repeatable read避免了不可重复读，但还有可能出现幻读</p><p><strong>可序列化</strong><br>Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主库将变更写入 <code>binlog</code> 日志，从库连接到主库之后，主库会创建一个<code>log dump</code> 线程，用于发送 <code>bin log</code> 的内容。<br>从库开启同步以后，会创建一个 IO 线程用来连接主库，请求主库中更新的 <code>bin log</code>，I/O 线程接收到主库 <code>binlog dump</code> 进程发来的更新之后，保存在本地 <code>relay</code> 日志中。<br>接着从库中有一个 SQL 线程负责读取 <code>relay log</code> 中的内容，同步到数据库存储中，也就是在自己本地进行回放，最终保证主从数据的一致性。</p><p><strong>主从复制下的延时问题</strong><br>解决这个问题的关键是要让从服务也用多线程并行复制binlog数据<br>MySQL自5.7版本后就已经支持并行复制了。可以在从服务上设置 <code>slave_parallel_workers</code>为一个大于0的数，然后把<code>slave_parallel_type</code>参数设置为<code> LOGICAL_CLOCK</code>，这就可以了</p><p><strong>为了解决主从同步延迟的问题，通常有以下几个方法</strong><br>1.敏感业务强制读主库<br>在开发中有部分业务需要写库后实时读数据，这一类操作通常可以通过强制读主库来解决<br>2.关键业务不进行读写分离<br>对一致性不敏感的业务，比如电商中的订单评论、个人信息等可以进行读写分离，对一致性要求比较高的业务，比如金融支付，不进行读写分离，避免延迟导致的问题。</p><h1 id="B-树比B树更适合数据库索引的原因"><a href="#B-树比B树更适合数据库索引的原因" class="headerlink" title="B+树比B树更适合数据库索引的原因"></a>B+树比B树更适合数据库索引的原因</h1><p>1.B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</p><p>2.由于非叶子节点不存储 data，所以一个节点可以存储更多的索引节点，每个节点能索引的范围更大更精确。也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高</p><p>3.B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询</p><p>*<em>使用B树的好处**</em><br>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><p><strong>使用B+树的好处</strong><br>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><p><strong>最佳左前缀法则</strong></p><ul><li>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且 不跳过索引中的列</li><li>不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描</li><li>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</li><li>尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *</li><li>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</li><li>索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描</li><li>索引字段使用like以通配符开头（%字符串）时，会导致索引失效而转向全表扫描</li><li>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</li><li>索引字段使用 or 时，会导致索引失效而转向全表扫描</li></ul><h1 id="MVCC的含义，如何实现的。"><a href="#MVCC的含义，如何实现的。" class="headerlink" title="MVCC的含义，如何实现的。"></a>MVCC的含义，如何实现的。</h1><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC，是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。<br>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><h1 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h1><p>MySQL主键不是自增长，会发生页分裂<br>索引运作的一个核心基础就是要求你后一个 数据页的主键值都大于前面一个数据页的主键值，但是如果你的主键是自增的，那还可以保证这一点， 因为你新插入后一个数据页的主键值一定都大于前一个数据页的主键值。<br>但是有时候你的主键并不是自增长的，所以可能会出现你后一个数据页的主键值里，有的主键是小于前一个数据页的主键值的<br>页分裂的过程，核心目标就是保证下一个数据页里的主键值都比上一个数据页里的主键值要大</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>面试</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis知识点总结</title>
    <link href="/2021/05/06/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2021/05/06/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h1><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p><ul><li><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>命令序列化，按顺序执行</li><li>原子性</li><li>三阶段: 开始事务 - 命令入队 - 执行事务</li><li>命令：MULTI/EXEC/DISCARD</li></ul></li><li><h3 id="发布订阅-Pub-Sub"><a href="#发布订阅-Pub-Sub" class="headerlink" title="发布订阅(Pub/Sub)"></a>发布订阅(Pub/Sub)</h3><ul><li>Pub/sub是一种消息通讯模式</li><li>Pub发送消息, Sub接受消息</li><li>Redis客户端可以订阅任意数量的频道</li><li>“fire and forgot”, 发送即遗忘</li><li>命令：Publish/Subscribe/Psubscribe/UnSub</li></ul></li></ul><p>相比于其他数据库类型，Redis具备的特点是：</p><ul><li>C/S通讯模型</li><li>单进程单线程模型</li><li>丰富的数据类型</li><li>操作具有原子性</li><li>持久化</li><li>高并发读写</li><li>支持lua脚本</li></ul><h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><p><strong>String类型：</strong><br>它是一个二进制安全的字符串，意味着它不仅能够存储字符串、还能存储图片、视频等多种类型, 最大长度支持512M。<br>对每种数据类型，Redis都提供了丰富的操作命令，如：<br>GET/MGET<br>SET/SETEX/MSET/MSETNX<br>INCR/DECR<br>GETSET<br>DEL</p><p><strong>哈希类型：</strong><br>该类型是由field和关联的value组成的map。其中，field和value都是字符串类型的。<br>Hash的操作命令如下：<br>HGET/HMGET/HGETALL<br>HSET/HMSET/HSETNX<br>HEXISTS/HLEN<br>HKEYS/HDEL<br>HVALS<br>列表类型：<br>该类型是一个插入顺序排序的字符串元素集合, 基于双链表实现。</p><p><strong>List的操作命令如下：</strong><br>LPUSH/LPUSHX/LPOP/RPUSH/RPUSHX/RPOP/LINSERT/LSET<br>LINDEX/LRANGE<br>LLEN/LTRIM</p><p><strong>集合类型：</strong><br>Set类型是一种无顺序集合, 它和List类型最大的区别是：集合中的元素没有顺序, 且元素是唯一的。<br>Set类型的底层是通过哈希表实现的，其操作命令为：<br>SADD/SPOP/SMOVE/SCARD<br>SINTER/SDIFF/SDIFFSTORE/SUNION<br>Set类型主要应用于：在某些场景，如社交场景中，通过交集、并集和差集运算，通过Set类型可以非常方便地查找共同好友、共同关注和共同偏好等社交关系。</p><p><strong>顺序集合类型：</strong><br>ZSet是一种有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。<br>ZSet命令：<br>ZADD/ZPOP/ZMOVE/ZCARD/ZCOUNT<br>ZINTER/ZDIFF/ZDIFFSTORE/ZUNION</p><h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">CONFIG SET maxmemory 4gb   // 设置缓存大小<br></code></pre></div></td></tr></table></figure><p><strong>noeviction 策略:默认</strong><br>一旦缓存被写满了，再有写请求来时，<code>Redis</code> 不再提供服务，而是直接返回错误</p><p><strong>volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu 这四种淘汰策略:·</strong></p><ul><li><p>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</p></li><li><p>volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p></li><li><p>volatile-lru 会使用 <code>LRU</code> 算法筛选设置了过期时间的键值对。</p></li><li><p>volatile-lfu 会使用<code>LFU</code> 算法选择设置了过期时间的键值对。</p></li></ul><p><strong>allkeys-lru、allkeys-random、allkeys-lfu 这三种淘汰策略:</strong></p><ul><li><p>allkeys-random 策略，从所有键值对中随机选择并删除数据；</p></li><li><p>allkeys-lru 策略，使用 <code>LRU</code> 算法在所有数据中进行筛选。</p></li><li><p>allkeys-lfu 策略，使用 <code>LFU</code> 算法在所有数据中进行筛选。</p></li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU 会把所有的数据组织成一个链表，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据<br>缺点:</p><ul><li>使用链表, 有额外空间开销</li><li>当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><p>在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p><blockquote><p>利用时间戳来优化</p></blockquote><p>Redis 提供了一个配置参数<code>maxmemory-samples</code>，这个参数就是 Redis 选出的数据个数 N。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">CONFIG <span class="hljs-keyword">SET</span> maxmemory-samples <span class="hljs-comment">100</span><br></code></pre></div></td></tr></table></figure><p>使用建议:</p><ul><li>优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。</li><li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。</li><li>如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。</li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 持久化（也称作快照持久化）是指将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是<code> .rdb</code><br>rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取 rdb 快照文件恢复数据<br>最核心的是 rdbSave 和 rdbLoad 两个函数， 前者用于生成 RDB 文件并保存到磁盘，而后者则用于将 RDB 文件中的数据重新载入到内存中</p><p><strong>BGSAVE 是触发 RDB 持久化的主流方式</strong></p><ul><li>客户端发起 BGSAVE 命令，Redis 主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回</li><li>父进程 fork 一个子进程 （fork 的过程中会造成阻塞的情况），这个过程可以使用 info stats 命令查看<code>latest_fork_usec</code>选项，查看最近一次 fork 操作消耗的时间，单位是微秒</li><li>父进程 fork 完成之后，则会返回 Background saving started 的信息提示，此时 fork 阻塞解除</li><li>fork 创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件</li><li>子进程备份完毕后向父进程发送完成信息，父进程更新统计信息</li></ul><p><strong>RDB 的优缺点</strong></p><blockquote><p>优点</p></blockquote><ul><li>RDB 是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份、灾难恢复</li><li>可以最大化 Redis 的性能，在保存 RDB 文件，服务器进程只需 fork 一个子进程来完成 RDB 文件的创建，父进程不需要做 IO 操作</li><li>与 AOF 持久化方式相比，恢复大数据集的时候会更快</li></ul><blockquote><p>缺点</p></blockquote><ul><li>RDB 的数据安全性是不如 AOF 的，保存整个数据集是个重量级的过程，根据配置可能要几分钟才进行一次持久化，如果服务器宕机，那么就可能丢失几分钟的数据</li><li>Redis 数据集较大时，fork 的子进程要完成快照会比较耗费 CPU 和时间</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><strong>AOF的执行流程</strong><br>AOF 文件的写入流程可以分为以下 3 个步骤：</p><ol><li>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 <code>aof_buf</code></li><li>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 <code>aof_buf</code> 的数据同步到硬盘</li><li>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩</li></ol><p><strong>文件写入和文件同步</strong></p><p>Redis 提供了多种 AOF 缓存区的文件同步策略，相关策略涉及到操作系统的 write() 函数和 fsync() 函数，说明如下：</p><blockquote><ol><li>write()</li></ol></blockquote><p>为了提高文件的写入效率，当用户调用 write 函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p><blockquote><ol><li>fsync()</li></ol></blockquote><p>虽然操作系统底层对 write() 函数进行了优化 ，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数 fsync() ，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。</p><p>Redis 提供了 appendfsync 配置项来控制 AOF 缓存区的文件同步策略，appendfsync 可配置以下三种策略：</p><ul><li><strong>appendfsync always</strong>：每执行一次命令保存一次</li></ul><p>命令写入 <code>aof_buf</code> 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的</p><ul><li><strong>appendfsync no</strong>：不保存</li></ul><p>命令写入 <code>aof_buf</code> 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒</p><ul><li><strong>appendfsync everysec</strong>：每秒钟保存一次</li></ul><p>命令写入 <code>aof_buf </code>缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次</p><p>everysec 是前述两种策略的折中，是性能和数据安全性的平衡，因此也是 Redis 的默认配置，也是比较推崇的配置选项</p><h2 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h2><p>随着命令不断写入 AOF，文件会越来越大，导致文件占用空间变大，数据恢复时间变长。为了解决这个问题，Redis 引入了重写机制来对 AOF 文件中的写命令进行合并，进一步压缩文件体积。</p><p>AOF 文件重写指的是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件，这个过程不对旧的 AOF 文件的进行任何读写操作。</p><p><strong>重写流程</strong></p><p>下面以手动触发 AOF 重写为例，当 bgrewriteaof 命令被执行时，AOF 文件重写的流程如下：</p><ul><li>客户端通过 bgrewriteaof 命令对 Redis 主进程发起 AOF 重写请求</li><li>当前不存在正在执行 <code>bgsave/bgrewriteaof</code> 的子进程时，Redis 主进程通过 fork 操作创建子进程，这个过程主进程是阻塞的。如果发现 bgrewriteaof 子进程直接返回；如果发现 bgsave 子进程则等 bgsave 执行完成后再执行 fork 操作</li></ul><p>主进程的 fork 操作完成后，继续处理其他命令，把新的写命令同时追加到 <code>aof_buf</code> 和 <code>aof_rewrite_buf</code> 缓冲区中</p><ul><li>在文件重写完成之前，主进程会继续把写命令追加到 <code>aof_buf</code> 缓冲区，根据 appendfsync 策略同步到旧的 AOF 文件，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性</li><li>由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 <code>aof_rewrite_buf</code> 缓冲区中，避免 AOF 重写时丢失这部分数据</li></ul><p>子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件</p><p>子进程写完新的 AOF 文件后，向主进程发信号，主进程更新统计信息，具体可以通过 info persistence 查看</p><p>主进程接受到子进程的信号以后，将 <code>aof_rewrite_buf</code> 缓冲区中的写命令追加到新的 AOF 文件</p><p>主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成</p><p><strong>AOF 的优缺点</strong></p><blockquote><p>优点</p></blockquote><ul><li>数据更完整，安全性更高，秒级数据丢失（取决于 fsync 策略，如果是 everysec，最多丢失 1 秒的数据）</li><li>AOF 文件是一个只进行追加的命令文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复</li></ul><blockquote><p>缺点</p></blockquote><ul><li>对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。不过在一般情况下， 每秒 fsync 的性能依然非常高</li></ul><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p><strong>Cache Aside Pattern</strong><br>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，然后再删除缓存。</li></ul><p><strong>先删除缓存再更新DB</strong><br>两个并发操作，一个是更新操作，另一个是查询操作，删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库，于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了</p><p><strong>先更新DB再删除缓存</strong><br>一个是查询操作，一个是更新操作的并发，首先，没有了删除<code>cache</code>数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来，而不会像上面那个，后续的查询操作一直都在取老的数据</p><p><strong>解决方案大概有以下几种：</strong><br>对删除缓存进行重试，数据的一致性要求越高，我越是重试得快<br>定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载<br>给所有的缓存一个失效期</p><h1 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>如果请求一个不存在的数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透<br>如果每次都拿一个不存在的数据去查询数据库，可能会导致你的数据库压力增大<br><strong>解决办法</strong><br>1.缓存空值<br>我们可以为这些不存在<code>key</code>在缓存中设置对应的值为<code>null</code>，后面查询这个<code>key</code>的时候就不用查询数据库了，为了健壮性，我们要对这些<code>key</code>设置过期时间，以防止真的有数据<br>2.BloomFilter（布隆过滤器）<br>我们把有数据的<code>key</code>都放到<code>BloomFilter</code>中，每次查询的时候都先<code>去BloomFilter</code>判断，如果没有就直接返回null</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs htm">布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:<br><br>1. 网页爬虫对URL的去重，避免爬取相同的URL地址<br>2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）<br>3. 缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。<br>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉<br></code></pre></div></td></tr></table></figure><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，就是说某个 <code>key</code> 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 <code>key</code> 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库<br><strong>解决办法</strong><br>1.可将该热点数据设置为永不过期<br>2.采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当某一时刻发生大规模的缓存失效的情况<br><strong>解决办法</strong><br>1.Ehcache本地缓存+<code>Hystrix</code>限流&amp;降级<br>2.设置不同的失效时间<br>3.采用缓存击穿的解决办法，加锁<br>4.永不失效，就是采用定时任务对快要失效的缓存进行更新缓存和失效时间</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>redis</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size() - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.size() - i - <span class="hljs-number">1</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>bubbleSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size()<span class="hljs-number">-1</span>; i++) &#123;<br><span class="hljs-keyword">int</span> minIndex = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.size(); j++) &#123;<br><span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>minIndex = j;<br>&#125;<br>&#125;<br>swap(arr[i], arr[minIndex]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>selectSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.size(); i++) &#123;<br><span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j - <span class="hljs-number">1</span>]);<br>j--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>insertSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.size() / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> groupStartIndex = <span class="hljs-number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;<br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.size(); currentIndex += gap) &#123;<br><span class="hljs-keyword">int</span> curNum = arr[currentIndex];<br><span class="hljs-keyword">int</span> pIndex = currentIndex - gap;<br><span class="hljs-keyword">while</span> (pIndex &gt;= groupStartIndex &amp;&amp; curNum &lt; arr[pIndex]) &#123;<br><span class="hljs-comment">// 向后挪位置</span><br>arr[pIndex + gap] = arr[pIndex];<br>pIndex -= gap;<br>&#125;<br>arr[pIndex + gap] = curNum;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>shellSort(arr);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp; arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pivot = arr[start];  <span class="hljs-comment">// 取第一个数为基数</span><br>    <span class="hljs-keyword">int</span> left = start + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 从第二个数开始分区</span><br>    <span class="hljs-keyword">int</span> right = end;        <span class="hljs-comment">// 右边界</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 找到第一个大于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;<br>        <span class="hljs-comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span><br>        <span class="hljs-keyword">if</span> (left != right) &#123;<br>            swap(arr[left], arr[right]);<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span><br>    <span class="hljs-keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;<br>    <span class="hljs-comment">// 将基数和中间数交换</span><br>    <span class="hljs-keyword">if</span> (right != start) swap(arr[start],arr[right]);<br>    <span class="hljs-comment">// 返回中间值的下标</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果区域内的数字少于 2 个，退出递归</span><br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将数组分区，并获得中间值的下标</span><br>    <span class="hljs-keyword">int</span> middle = partition(arr, start, end);<br>    quickSort(arr, start, middle - <span class="hljs-number">1</span>);<br>    quickSort(arr, middle + <span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br>quickSort(arr,<span class="hljs-number">0</span>,arr.size()<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 建立父節點指標和子節點指標</span><br>    <span class="hljs-keyword">int</span> dad = start;<br>    <span class="hljs-keyword">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span><br>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span><br>            son++;<br>        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span><br>            swap(arr[dad], arr[son]);<br>            dad = son;<br>            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        max_heapify(arr, i, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(arr[<span class="hljs-number">0</span>], arr[i]);<br>        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);<br>    heap_sort(arr, len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客输入输出练习</title>
    <link href="/2021/03/25/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/03/25/%E7%89%9B%E5%AE%A2%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="编程题-A-B-1"><a href="#编程题-A-B-1" class="headerlink" title="[编程题]A+B(1)"></a>[编程题]A+B(1)</h1><p>输入描述</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入包括两个正整数<span class="hljs-selector-tag">a</span>,b(<span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>),输入数据包括多组。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b)&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; a+b &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-2"><a href="#编程题-A-B-2" class="headerlink" title="[编程题]A+B(2)"></a>[编程题]A+B(2)</h1><p>输入描述</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">输入第一行包括一个数据组数t<span class="hljs-comment">(1 &lt;= t &lt;= 100)</span><br>接下来每行包括两个正整数a,b<span class="hljs-comment">(1 &lt;= a, b &lt;= 10^9)</span><br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-3"><a href="#编程题-A-B-3" class="headerlink" title="[编程题]A+B(3)"></a>[编程题]A+B(3)</h1><p>输入描述</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入包括两个正整数<span class="hljs-selector-tag">a</span>,b(<span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span>),输入数据有多组, 如果输入为<span class="hljs-number">0</span> <span class="hljs-number">0</span>则结束输入<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">输出a</span><span class="hljs-literal">+</span><span class="hljs-comment">b的结果</span><br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">6<br>30<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>&amp;&amp;b==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a+b);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-4"><a href="#编程题-A-B-4" class="headerlink" title="[编程题]A+B(4)"></a>[编程题]A+B(4)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>), <span class="hljs-built_in">n</span>为<span class="hljs-number">0</span>的时候结束输入。<br>接下来<span class="hljs-built_in">n</span>个正整数,即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num) &amp;&amp; num != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-5"><a href="#编程题-A-B-5" class="headerlink" title="[编程题]A+B(5)"></a>[编程题]A+B(5)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入的第一行包括一个正整数<span class="hljs-built_in">t</span>(<span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">t</span> &lt;= <span class="hljs-number">100</span>), 表示数据组数。<br>接下来<span class="hljs-built_in">t</span>行, 每行一组数据。<br>每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>)。<br>接下来<span class="hljs-built_in">n</span>个正整数, 即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> groups, num, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;groups);<br>    <span class="hljs-keyword">while</span>(groups--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="编程题-A-B-6"><a href="#编程题-A-B-6" class="headerlink" title="[编程题]A+B(6)"></a>[编程题]A+B(6)</h1><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数<span class="hljs-built_in">n</span>(<span class="hljs-comment">1 &lt;= n &lt;= 100</span>)。<br>接下来<span class="hljs-built_in">n</span>个正整数, 即需要求和的每个正整数。<br></code></pre></div></td></tr></table></figure><p>输出描述</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></div></td></tr></table></figure><p>输入例子</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>输出例子</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">10<br>15<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> groups, num, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;groups);<br>    <span class="hljs-keyword">while</span>(groups--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;val);<br>            sum += val;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题整理</title>
    <link href="/2021/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h3><ol><li><p>首先说一下面向对象和面向过程：</p><ul><li>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。</li><li>面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。</li></ul></li><li><p>区别和联系：</p><ul><li>语言自身：C 语言是面向过程的编程，它最重要的特点是<strong>函数</strong>，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。C++ 是面向对象的编程，<strong>类</strong>是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数</li><li>，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句。），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</li><li>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li><li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 const 关键字，等等。</li><li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li></ul></li></ol><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。<strong>（是否可变）</strong></li><li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。<strong>（是否占内存）</strong></li><li>指针可以为空，但是引用必须绑定对象。<strong>（是否可为空）</strong></li><li>指针可以有多级，但是引用只能一级。<strong>（是否能为多级）</strong></li></ul><h3 id="malloc-和new，free和delete的区别"><a href="#malloc-和new，free和delete的区别" class="headerlink" title="malloc 和new，free和delete的区别"></a>malloc 和new，free和delete的区别</h3><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p><ul><li>malloc、free 是库函数，而new、delete 是关键字。<br><code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</li><li><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。</li><li>new 分配失败时，会抛出 <code>bad_alloc </code>异常，<code>malloc</code> 分配失败时返回空指针。</li><li>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 free 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。<br><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</li></ul><h3 id="extern-C的作用"><a href="#extern-C的作用" class="headerlink" title="extern C的作用"></a>extern C的作用</h3><p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p><h3 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h3><ul><li><p><code>volatile</code> 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <code>violatile</code>，告知编译器不应对这样的对象进行优化。</p></li><li><p><code>volatile</code>不具有原子性。</p></li><li><p><code>volatile</code> 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h1><p>虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页（page），每个页都是一段连续的地址。这些页被映射到物理内存（页表），但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块（称为帧，通常页和帧大小相等），还有一些没有加载在内存中的对应在硬盘上。</p><p>虚拟内存实际比物理内存要大，当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如上图的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如上图的3，4），会产生缺页中断，从硬盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将硬盘中的页换出来。</p><h1 id="虚拟内存实现"><a href="#虚拟内存实现" class="headerlink" title="虚拟内存实现"></a>虚拟内存实现</h1><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong></p><p>虚拟内存的实现有以下三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换</li></ol><h1 id="内存管理有哪几种方式"><a href="#内存管理有哪几种方式" class="headerlink" title="内存管理有哪几种方式"></a>内存管理有哪几种方式</h1><ol><li><strong>块式管理</strong> ：将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。 段式管理通过段表对应逻辑地址和物理地址。</li><li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</li></ol><p><strong>逻辑(虚拟)地址和物理地址</strong></p><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位</p><p>每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p><p>在操作系统中能同时运行多个进程；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><ul><li><p>1.创建状态</p></li><li><p>2.就绪状态</p></li><li><p>运行状态</p></li><li><p>阻塞状态</p></li><li><p>终止状态</p></li></ul><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><ul><li>创建（NEW）状态：新建线程对象</li><li>可运行（RUNNABLE）状态：线程对象被创建之后，其他线程调用了该线程的start方法，该线程的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</li><li>运行（RUNNING）状态：可运行状态的线程获得了cpu时间片后，执行程序代码</li><li>阻塞（BLOKED）状态：进入阻塞状态的原因是线程因为某种原因放弃了cpu使用权，也就是让出了cpu时间片，暂时停止运行，只有等到线程再次进入可运行状态时，才有机会获得cpu时间片再次运行。<ul><li>阻塞状态分为三种，1.等待阻塞，即运行的线程执行wait方法，JVM就会将线程放入等待队列。2.同步阻塞，运行的线程在获取对象的同步锁时，如果这个同步锁此刻正在被别的线程占用，则JVM会将该线程放入锁池。3.其他阻塞，当运行的线程执行了sleep、join或者发出了IO请求的时候，JVM会将线程置为阻塞状态，当sleep超时，join等待线程终止或者超时、IO处理完毕时，线程可以重新转入运行态。</li></ul></li><li>死亡（DEAD）状态：现成的run、main方法执行接触，或者因异常推出run方法，则线程结束生命周期。死亡的线程不可以再次复生。</li></ul><h1 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h1><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</p><h2 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道/匿名管道"></a>管道/匿名管道</h2><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><h2 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h2><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。</p><p>为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。</p><p>值的注意的是，有名管道严格遵循先进先出，对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p><p>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</p><p>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p><p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p><p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p>为了获得共享资源，进程需要执行下列操作：</p><p>1.创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br>2.等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br>3.挂出一个信号量：该操作将信号量的值加1，也称为V操作。</p><h2 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字(Socket)"></a>套接字(Socket)</h2><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p><strong>临界区</strong></p><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p><p>优点：保证在某一时刻只有一个线程能访问数据的简便办法</p><p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程</p><p><strong>互斥量</strong></p><p>为协调共同对一个共享资源的单独访问而设计的</p><p>互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限</p><p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享</p><p><strong>信号量</strong></p><p>为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了</p><p><strong>事件</strong></p><p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p><p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作</p><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p><strong>先来先服务调度算法</strong></p><p>该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p><p><strong>短作业(进程)优先调度算法</strong></p><p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p><p><strong>时间片轮转法</strong></p><p>每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间</p><p><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p><p><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>1.系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p><p>2.进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</p><p><strong>四个必要条件</strong></p><p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</p><p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)</p><p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</p><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁</p><p><strong>只要我们破坏其中一个，就可以成功避免死锁的发生</strong></p><p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥</p><ol><li>对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li>对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于循环等待这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol><h1 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h1><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换</p><p>我们可以把快表理解为一种特殊的<strong>高速缓冲存储器（Cache）</strong>，其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>O多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程<br>目前支持I/O多路复用的系统调用有 <code>select，pselect，poll，epoll</code><br>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作<br>但<code>select，pselect，poll，epoll</code>本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，通过遍历<code>fdset</code>，来找到就绪的描述符。</p><p><strong>缺点</strong><br>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由<code>FD_SETSIZE</code>设置，默认值是1024<br>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll本质上和<code>select</code>没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个<code>fd</code>对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历<br>它没有最大连接数的限制，原因是它是基于链表来存储的<br>poll还有一个特点是<strong>水平触发</strong>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次<br>epoll使用事件的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，<code>epoll_wait</code>便可以收到通知<br>epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，<code>epoll_wait</code>的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数<br><strong>优点：</strong><br>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。<br>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即<code>Epoll</code>最大的优点就在于它只管你活跃的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p>内存拷贝，利用<code>mmap()</code>文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销</p><p><strong>文件描述符的操作有两种模式：LT和ET</strong></p><p>LT模式是默认模式，LT模式与ET模式的区别如下：<br>LT模式：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用<code>epoll_wait</code>时，会再次响应应用程序并通知此事件。</p><p>ET模式：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用<code>epoll_wait</code>时，不会再次响应应用程序并通知此事件。</p><p><strong>选择</strong><br>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。<br>select低效是因为每次它都需要轮询</p><h1 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO/NIO/AIO"></a>BIO/NIO/AIO</h1><ul><li>BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个线程不做任何事情会造成不必要的线程开销，当然可以通过线程池来改善。</li><li>NIO：同步非阻塞式IO，面向缓冲区，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。是基于事件驱动思想完成的。</li><li>AIO：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。reactor模型：反应器模式（事件驱动模式）：当一个主体发生改变时，所有的属性都得到通知，类似于观察者模式。</li></ul><h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><p>Reactor模型中定义的三种角色：<br><strong>Reactor</strong>：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。<br><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。<br><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理</p><h2 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h2><p>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</p><p>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</p><p>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</p><h2 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h2><p>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发</p><p>如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件</p><p>如果不是连接请求，则由 Reactor 分发调用连接对 应的Handler 来处理</p><p>Handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 Worker 线程池的某个线程处理业务</p><p>Worker 线程池会分配独立线程完成真正的业务， 并将结果返回给 Handler</p><p>Handler 收到响应后，通过 send 将结果返回给 Client</p><h1 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h1><p>流程与Reactor模式类似，区别在于proactor在IO ready事件触发后，完成IO操作再通知应用回调（被动）</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序的内存分区模型</title>
    <link href="/2021/02/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/02/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，则在程序结束时由操作系统回收</li></ul><p><strong>内存四区的意义</strong></p><p>不同区域存放的数据，赋予不同的生命周期，给予我们更加强大的灵活的编程</p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<strong>未执行</strong>该程序前分为两个区域</p><p><strong>代码区：</strong> </p><ul><li>存放CPU执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了他的指令</li></ul><p><strong>全局区：</strong></p><ul><li>全局变量和静态变量存放于此</li><li>全局区还包含了<strong>常量区</strong>，字符串常量和其他常量也存放在此</li><li><font color= red>该区域的数据在程序结束后由操作系统释放</font></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> g_b = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// const修饰的全局变量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_b = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// const局部变量</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;g_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;g_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const全局变量c_g_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const全局变量c_g_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串常量地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;<span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const局部变量a地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Const局部变量b地址： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_b &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 输出结果</span><br>全局变量g_a地址： 15188032<br>全局变量g_b地址： 15188036<br>Const全局变量c_g_a地址： 15178816<br>Const全局变量c_g_b地址： 15178820<br>静态变量s_a地址： 15188040<br>静态变量s_b地址： 15188044<br>字符串常量地址： 15179412<br><br>局部变量a地址： 4127340<br>局部变量b地址： 4127328<br>Const局部变量a地址： 4127316<br>Const局部变量b地址： 4127304<br></code></pre></div></td></tr></table></figure><p><strong>结论</strong><br><img src="https://i.loli.net/2021/02/21/p8xBk4WmhRtAv6z.png" alt="image-20210221011618438"></p><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p><strong>栈区</strong></p><p>由编译器自动分配释放，存放函数的参数值，局部变量等</p><p><em>注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</em></p><ul><li><p>为什么不能返回局部变量地址</p><p>当前函数被执行时，开辟该区域。在函数第一次运行时，编译器对变量地址进行保留，函数运行结束后，再进行新的运算时，地址将被销毁。返回的局部变量无法被二次使用。</p></li><li><p>函数的形参同样开辟在栈区，调用函数时，形参被分配内存，函数运行结束，形参地址被销毁</p></li></ul><p><strong>堆区</strong></p><p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p><p>在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 利用new关键字 可以将数据开辟到堆区</span><br>    <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 指针本质上仍是局部变量，保存在栈区，但是指针指向的内存地址是堆区区域</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>* p = func();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 输出结果</span><br>10<br><span class="hljs-comment"># 10将到程序员回收或程序结束才被释放</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>程序内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑暗之魂学习笔记【01-玩家输入模块】【02-平滑衰减】</title>
    <link href="/2021/02/15/%E9%BB%91%E6%9A%97%E4%B9%8B%E9%AD%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/02/15/%E9%BB%91%E6%9A%97%E4%B9%8B%E9%AD%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E7%8E%A9%E5%AE%B6%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="01-玩家输入模块"><a href="#01-玩家输入模块" class="headerlink" title="01-玩家输入模块"></a>01-玩家输入模块</h1><figure class="highlight c#"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 设置变量获取key的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyUp = <span class="hljs-string">&quot;w&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyDown = <span class="hljs-string">&quot;s&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyLeft = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyRight = <span class="hljs-string">&quot;d&quot;</span>;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 初步获取的键盘输入，只有0，1，-1，三个值</span><br>        dUp = (Input.GetKey(keyUp)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyDown)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        dRight = (Input.GetKey(keyRight)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyLeft)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>); <br>        <br>        <span class="hljs-keyword">if</span> (Input.GetKey(keyUp)) &#123;<br>        print(<span class="hljs-string">&quot;key up is pressed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="02-平滑衰减"><a href="#02-平滑衰减" class="headerlink" title="02-平滑衰减"></a>02-平滑衰减</h1><figure class="highlight c#"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerInput</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 通过变量，控制脚本的装载</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> inputEnabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// Variable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyUp = <span class="hljs-string">&quot;w&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyDown = <span class="hljs-string">&quot;s&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyLeft = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> keyRight = <span class="hljs-string">&quot;d&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> dUp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> dRight;<br>    <br>    <span class="hljs-comment">// 平滑过渡的坐标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _targetDUp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _targetDRight;<br>    <span class="hljs-comment">// 变化速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _velocityDUp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _velocityDRight;<br>    <br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 初步获取的键盘输入，只有0，1，-1，三个值</span><br>        _targetDUp = (Input.GetKey(keyUp)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyDown)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        _targetDRight = (Input.GetKey(keyRight)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>) - (Input.GetKey(keyLeft)? <span class="hljs-number">1.0f</span>:<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 设置脚本的装载</span><br>        <span class="hljs-keyword">if</span> (inputEnabled == <span class="hljs-literal">false</span>) &#123;<br>            _targetDUp = <span class="hljs-number">0</span>;<br>            _targetDRight = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 平滑函数的四个参数（当前坐标，目标坐标，速度参数，坐标变化的完成时间）</span><br>        dUp = Mathf.SmoothDamp(dUp, _targetDUp, <span class="hljs-keyword">ref</span> _velocityDUp, <span class="hljs-number">0.1f</span>);<br>        dRight = Mathf.SmoothDamp(dRight, _targetDRight, <span class="hljs-keyword">ref</span> _velocityDRight, <span class="hljs-number">0.1f</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>黑暗之魂学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
